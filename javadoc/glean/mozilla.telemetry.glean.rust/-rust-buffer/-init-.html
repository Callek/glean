<HTML>
<HEAD>
<meta charset="UTF-8">
<title>RustBuffer.<init> - glean</title>
<link rel="stylesheet" href="../../../style.css">
</HEAD>
<BODY>
<a href="../../index.html">glean</a>&nbsp;/&nbsp;<a href="../index.html">mozilla.telemetry.glean.rust</a>&nbsp;/&nbsp;<a href="index.html">RustBuffer</a>&nbsp;/&nbsp;<a href="./-init-.html">&lt;init&gt;</a><br/>
<br/>
<h1>&lt;init&gt;</h1>
<a name="mozilla.telemetry.glean.rust.RustBuffer$&lt;init&gt;()"></a>
<code><span class="identifier">RustBuffer</span><span class="symbol">(</span><span class="symbol">)</span></code>
<p>This is a mapping for the <code>glean_core::byte_buffer::ByteBuffer</code> struct.
It's a copy of the <code>support.native.RustBuffer</code> class in application-services,
with the small changes that the length field is a (32-bit) Int instead.</p>
<p>The name differs for two reasons.</p>
<ol><li>To that the memory this type manages is allocated from rust code,
    and must subsequently be freed by rust code.</li>

<li>To avoid confusion with java's nio ByteBuffer, which we use for
    passing data <em>to</em> Rust without incurring additional copies.</li>
</ol>
<h1>Caveats:</h1>
<ol><li>It is for receiving data <em>FROM</em> Rust, and not the other direction.
    RustBuffer doesn't expose a way to inspect its contents from Rust.
    See <code>docs/howtos/passing-protobuf-data-over-ffi.md</code> for how to do
    this instead.</li>

<li>
<p>A <code>RustBuffer</code> passed into kotlin code must be freed by kotlin
    code <em>after</em> the protobuf message is completely deserialized.</p>
   
<p> The rust code must expose a destructor for this purpose,
    and it should be called in the finally block after the data
    is read from the <code>CodedInputStream</code> (and not before).</p>
</li>

<li>You almost always should use <code>RustBuffer.ByValue</code> instead
    of <code>RustBuffer</code>. E.g.
    <code>fun mylib_get_stuff(some: X, args: Y): RustBuffer.ByValue</code>
    for the function returning the RustBuffer, and
    <code>fun mylib_destroy_bytebuffer(bb: RustBuffer.ByValue)</code>.</li>
</ol>
</BODY>
</HTML>
