<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Glean - Cross-platform Telemetry library</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="index.html"><strong aria-hidden="true">1.</strong> Glean</a></li><li><a href="user/index.html"><strong aria-hidden="true">2.</strong> Using the Glean SDK</a></li><li><ol class="section"><li><a href="user/adding-glean-to-your-project.html"><strong aria-hidden="true">2.1.</strong> Adding Glean to your project</a></li><li><a href="user/adding-new-metrics.html"><strong aria-hidden="true">2.2.</strong> Adding new metrics</a></li><li><a href="user/metric-parameters.html"><strong aria-hidden="true">2.3.</strong> Metric parameters</a></li><li><a href="user/testing-metrics.html"><strong aria-hidden="true">2.4.</strong> Testing metrics</a></li><li><a href="user/debugging.html"><strong aria-hidden="true">2.5.</strong> Debugging products using Glean</a></li><li><a href="user/error-reporting.html"><strong aria-hidden="true">2.6.</strong> Error reporting</a></li><li><a href="user/metrics/index.html"><strong aria-hidden="true">2.7.</strong> Metric types</a></li><li><ol class="section"><li><a href="user/metrics/boolean.html"><strong aria-hidden="true">2.7.1.</strong> Boolean</a></li><li><a href="user/metrics/counter.html"><strong aria-hidden="true">2.7.2.</strong> Counter</a></li><li><a href="user/metrics/labeled_counters.html"><strong aria-hidden="true">2.7.3.</strong> Labeled Counters</a></li><li><a href="user/metrics/string.html"><strong aria-hidden="true">2.7.4.</strong> String</a></li><li><a href="user/metrics/labeled_strings.html"><strong aria-hidden="true">2.7.5.</strong> Labeled Strings</a></li><li><a href="user/metrics/string_list.html"><strong aria-hidden="true">2.7.6.</strong> String List</a></li><li><a href="user/metrics/timespan.html"><strong aria-hidden="true">2.7.7.</strong> Timespan</a></li><li><a href="user/metrics/labeled_timespans.html"><strong aria-hidden="true">2.7.8.</strong> Labeled Timespans</a></li><li><a href="user/metrics/timing_distribution.html"><strong aria-hidden="true">2.7.9.</strong> Timing Distribution</a></li><li><a href="user/metrics/uuid.html"><strong aria-hidden="true">2.7.10.</strong> UUID</a></li><li><a href="user/metrics/datetime.html"><strong aria-hidden="true">2.7.11.</strong> Datetime</a></li><li><a href="user/metrics/event.html"><strong aria-hidden="true">2.7.12.</strong> Event</a></li></ol></li><li><a href="user/pings/index.html"><strong aria-hidden="true">2.8.</strong> Pings</a></li><li><ol class="section"><li><a href="user/pings/baseline.html"><strong aria-hidden="true">2.8.1.</strong> Baseline Ping</a></li><li><a href="user/pings/metrics.html"><strong aria-hidden="true">2.8.2.</strong> Metrics Ping</a></li><li><a href="user/pings/events.html"><strong aria-hidden="true">2.8.3.</strong> Events Ping</a></li><li><a href="user/pings/custom.html"><strong aria-hidden="true">2.8.4.</strong> Custom Pings</a></li><li><a href="user/pings/testing-custom-pings.html"><strong aria-hidden="true">2.8.5.</strong> Testing custom pings</a></li></ol></li></ol></li><li><a href="dev/index.html"><strong aria-hidden="true">3.</strong> Developing the Glean SDK</a></li><li><ol class="section"><li><a href="dev/testing.html"><strong aria-hidden="true">3.1.</strong> Testing</a></li><li><a href="dev/android/index.html"><strong aria-hidden="true">3.2.</strong> Android bindings</a></li><li><ol class="section"><li><a href="dev/android/setup-android-build-environment.html"><strong aria-hidden="true">3.2.1.</strong> Setup Build Environment</a></li></ol></li><li><a href="dev/core/index.html"><strong aria-hidden="true">3.3.</strong> Rust Component</a></li><li><ol class="section"><li><a href="dev/core/dependency-management.html"><strong aria-hidden="true">3.3.1.</strong> Dependency Management</a></li><li><a href="dev/core/new-metric-type.html"><strong aria-hidden="true">3.3.2.</strong> Adding a new metric type</a></li><li><a href="dev/core/internal.html"><strong aria-hidden="true">3.3.3.</strong> Internal design details</a></li></ol></li><li><a href="dev/ffi/index.html"><strong aria-hidden="true">3.4.</strong> FFI Layer</a></li><li><ol class="section"><li><a href="dev/ffi/when-to-use-what-in-the-ffi.html"><strong aria-hidden="true">3.4.1.</strong> When/How FFI</a></li></ol></li><li><a href="contributing.html"><strong aria-hidden="true">3.5.</strong> Contributing</a></li></ol></li><li><a href="api/index.html"><strong aria-hidden="true">4.</strong> API Documentation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Glean - Cross-platform Telemetry library</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#glean-sdk" id="glean-sdk">Glean SDK</a></h1>
<p><img src="glean.jpeg" alt="Glean logo" /></p>
<p><em>Modern telemetry for mobile platforms</em></p>
<p>The <code>Glean SDK</code> is a modern approach for a mobile Telemetry library and is part of the <a href="https://docs.telemetry.mozilla.org/concepts/glean/glean.html">Glean project</a>.</p>
<p>There currently two independent implementations of the Glean SDK, both sharing the documentation here:</p>
<ul>
<li>An Android-only implementation in <a href="https://github.com/mozilla-mobile/android-components/tree/master/components/service/glean">android-components</a>.</li>
<li>A <a href="https://github.com/mozilla/glean/">cross-platform implementation</a>.  (This implementation is currently under development and not ready for use).</li>
</ul>
<p>To contact us you can:</p>
<ul>
<li>Find us on the Mozilla Slack in <em>#glean</em>, on <a href="https://wiki.mozilla.org/IRC">Mozilla IRC</a> in <em>#telemetry</em>.</li>
<li>To report issues or request changes, file a bug in <a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Data%20Platform%20and%20Tools&amp;component=Glean%3A%20SDK">Bugzilla in Data Platform &amp; Tools :: Glean: SDK</a>.</li>
<li>Send an email to <em>glean-team@mozilla.com</em>.</li>
<li>The Glean SDK team is: <em>:janerik</em>, <em>:dexter</em>, <em>:travis</em>, <em>:mdroettboom</em>, <em>:gfritzsche</em>, <em>:chutten</em></li>
</ul>
<h2><a class="header" href="#license" id="license">License</a></h2>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/</p>
<h1><a class="header" href="#using-the-glean-sdk" id="using-the-glean-sdk">Using the Glean SDK</a></h1>
<p>In this chapter we describe how to use the Glean SDK in your own libraries and applications.</p>
<h1><a class="header" href="#adding-glean-to-your-project" id="adding-glean-to-your-project">Adding Glean to your project</a></h1>
<h2><a class="header" href="#before-using-glean" id="before-using-glean">Before using Glean</a></h2>
<p>Products using the Glean SDK to collect telemetry <strong>must</strong>:</p>
<ul>
<li>add documentation for any new metric collected with the library in its repository (see <a href="user/pings/index.html">an example</a>);</li>
<li>go through data review for the newly collected data by following <a href="https://wiki.mozilla.org/Firefox/Data_Collection">this process</a>;</li>
<li>provide a way for users to turn data collection off (e.g. providing settings to control
<code>Glean.setUploadEnabled()</code>).</li>
</ul>
<h2><a class="header" href="#usage" id="usage">Usage</a></h2>
<h3><a class="header" href="#setting-up-the-dependency" id="setting-up-the-dependency">Setting up the dependency</a></h3>
<p>Use Gradle to download the library from <a href="https://maven.mozilla.org/">maven.mozilla.org</a>
(<a href="user/../../../README.html#maven-repository">Setup repository</a>):</p>
<pre><code class="language-Groovy">implementation &quot;org.mozilla.components:service-glean:{latest-version}&quot;
</code></pre>
<h3><a class="header" href="#integrating-with-the-build-system" id="integrating-with-the-build-system">Integrating with the build system</a></h3>
<p>In order for the Glean SDK to generate an API for your metrics, a Python environment must be accessible at build time.
This is done automatically by the <a href="https://github.com/JetBrains/gradle-python-envs/"><code>com.jetbrains.python.envs</code></a> plugin.
The plugin <strong>must</strong> be manually enabled by adding the following <code>plugins</code> block at the top of the <code>build.gradle</code> file for your app module.</p>
<pre><code class="language-Groovy">plugins {
    id &quot;com.jetbrains.python.envs&quot; version &quot;0.0.26&quot;
}
</code></pre>
<p>Right before the end of the same file, the Glean SDK build script must be included.
This script can be referenced directly from the GitHub repo, as shown below:</p>
<pre><code class="language-Groovy">apply from: 'https://github.com/mozilla/glean/raw/v{latest-version}/glean-core/android/sdk_generator.gradle'
</code></pre>
<blockquote>
<p><strong>Important:</strong> the <code>{latest-version}</code> placeholder in the above link should be replaced with the version number of the Glean SDK used by the project.
For example, if version <em>0.34.2</em> is used, then the include directive becomes:</p>
</blockquote>
<pre><code class="language-Groovy">apply from: 'https://github.com/mozilla/glean/raw/v0.34.2/glean-core/android/sdk_generator.gradle'
</code></pre>
<h3><a class="header" href="#adding-new-metrics" id="adding-new-metrics">Adding new metrics</a></h3>
<p>All metrics that your project collects must be defined in a <code>metrics.yaml</code> file.
This file should be at the root of the module (the same directory as the <code>build.gradle</code> file you updated).
The format of that file is documented <a href="https://mozilla.github.io/glean_parser/metrics-yaml.html">with <code>glean_parser</code></a>.
To learn more, see <a href="user/adding-new-metrics.html">adding new metrics</a>.</p>
<blockquote>
<p><strong>Important</strong>: as stated <a href="user/#before-using-glean">above</a>, any new data collection requires documentation and data-review. This is also required for any new metric automatically collected by the Glean SDK.</p>
</blockquote>
<h3><a class="header" href="#adding-custom-pings" id="adding-custom-pings">Adding custom pings</a></h3>
<p>Please refer to the <a href="user/pings/custom.html">custom pings documentation</a>.</p>
<blockquote>
<p><strong>Important</strong>: as stated <a href="user/#before-using-glean">above</a>, any new data collection, including new custom pings, requires documentation and data-review. This is also required for any new ping automatically collected by the Glean SDK.</p>
</blockquote>
<h3><a class="header" href="#testing-metrics" id="testing-metrics">Testing metrics</a></h3>
<p>In order to make testing metrics easier 'out of the box', all metrics include a set of test API functions in order to facilitate unit testing.  These include functions to test whether a value has been stored, and functions to retrieve the stored value for validation.  For more information, please refer to <a href="user/testing-metrics.html">Unit testing Glean metrics</a>.</p>
<h3><a class="header" href="#adding-metadata-about-your-project-to-the-pipeline" id="adding-metadata-about-your-project-to-the-pipeline">Adding metadata about your project to the pipeline</a></h3>
<p>In order for data to be collected from your project, metadata must be added to <code>probe_scraper</code>.</p>
<p>These specific steps are described in <a href="https://github.com/mozilla/probe-scraper#adding-a-new-glean-repository">the <code>probe_scraper</code> documentation</a>.</p>
<h2><a class="header" href="#application-specific-steps" id="application-specific-steps">Application-specific steps</a></h2>
<p>The following steps are required for applications using the Glean SDK, but not libraries.</p>
<h3><a class="header" href="#initializing-the-glean-sdk" id="initializing-the-glean-sdk">Initializing the Glean SDK</a></h3>
<p>The Glean SDK should only be initialized from the main application, not individual libraries.  If you are adding Glean support to a library, you can safely skip this section.
Please also note that the Glean SDK does not support use across multiple processes, and must only be initialized on the application's main process. Initializing in other processes is a no-op.</p>
<p>Before any data collection can take place, the Glean SDK <strong>must</strong> be initialized from the application.
An excellent place to perform this operation is within the <code>onCreate</code> method of the class that extends Android's <code>Application</code> class.</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Pings

class SampleApplication : Application() {

    override fun onCreate() {
        super.onCreate()

        // If you have custom pings in your application, you must register them
        // using the following command. This command should be omitted for
        // applications not using custom pings.
        Glean.registerPings(Pings)

        // Call setUploadEnabled first, since Glean.initialize
        // might send pings if there are any metrics queued up
        // from a previous run.
        Glean.setUploadEnabled(Settings.isTelemetryEnabled)

        // Initialize the Glean library.
        Glean.initialize(applicationContext)
    }
}
</code></pre>
<p>Once initialized, if collection is enabled, the Glean SDK will automatically start collecting <a href="user/pings/metrics.html">baseline metrics</a> and sending its <a href="user/pings/index.html">pings</a>.</p>
<p>The Glean SDK should be initialized as soon as possible, and importantly, before any other libraries in the application start using Glean.
Library code should never call <code>Glean.initialize</code>, since it should be called exactly once per application.</p>
<blockquote>
<p><strong>Note</strong>: if the application has the concept of release channels and knows which channel it is on at run-time, then it can provide the Glean SDK with this information by setting it as part of the <code>Configuration</code> object parameter of the <code>Glean.initialize</code> method. For example:</p>
</blockquote>
<pre><code class="language-Kotlin">Glean.initialize(applicationContext, Configuration(channel = &quot;beta&quot;))
</code></pre>
<h3><a class="header" href="#enabling-and-disabling-metrics" id="enabling-and-disabling-metrics">Enabling and disabling metrics</a></h3>
<p><code>Glean.setUploadEnabled()</code> should be called in response to the user enabling or disabling telemetry.
This method should also be called at least once prior to calling <code>Glean.initialize()</code>.</p>
<p>The application should provide some form of user interface to call this method.</p>
<p>When going from enabled to disabled, all pending events, metrics and pings are cleared, except for <code>first_run_date</code>.
When re-enabling, core Glean metrics will be recomputed at that time.</p>
<h1><a class="header" href="#adding-new-metrics-1" id="adding-new-metrics-1">Adding new metrics</a></h1>
<p>All metrics that your project collects must be defined in a <code>metrics.yaml</code> file. 
This file should be at the root of the application or library module (the same directory as the <code>build.gradle</code> file you updated). 
The format of that file is documented <a href="https://mozilla.github.io/glean_parser/metrics-yaml.html">here</a>.</p>
<p>When adding a new metric, the workflow is:</p>
<ul>
<li>Decide on which <a href="user/metrics/index.html">metric type</a> you want to use.</li>
<li>Add a new entry to <a href="user/#The-metricsyaml-file"><code>metrics.yaml</code></a>.</li>
<li>Add code to your project to record into the metric by calling the Glean SDK.</li>
</ul>
<blockquote>
<p><strong>Important</strong>: Any new data collection requires documentation and data-review.
This is also required for any new metric automatically collected by the Glean SDK.</p>
</blockquote>
<h2><a class="header" href="#the-metricsyaml-file" id="the-metricsyaml-file">The <code>metrics.yaml</code> file</a></h2>
<p>The <code>metrics.yaml</code> file defines the metrics your application or library will send. 
They are organized into categories.
The overall organization is:</p>
<pre><code class="language-YAML"># Required to indicate this is a `metrics.yaml` file
$schema: moz://mozilla.org/schemas/glean/metrics/1-0-0

toolbar:
  click:
    type: event
    description: |
      Event to record toolbar clicks.
    notification_emails:
      - CHANGE-ME@example.com
    bugs:
      - 123456789
    data_reviews:
      - http://example.com/path/to/data-review
    expires:
      - 2019-06-01  # &lt;-- Update to a date in the future
    
  metric2:
    ...
    
category2.subcategory:  # Categories can contain subcategories
  metric3:
    ...

</code></pre>
<p>The details of the metric parameters are described in <a href="user/metric-parameters.html">metric parameters</a>.</p>
<p>The <code>metrics.yaml</code> file is used to generate <code>Kotlin</code> code that becomes the public API to access your application's metrics.</p>
<h2><a class="header" href="#metric-naming" id="metric-naming">Metric naming</a></h2>
<p>Category and metric names in the <code>metrics.yaml</code> are in <code>snake_case</code>, but given the Kotlin coding standards defined by <a href="https://github.com/pinterest/ktlint">ktlint</a>, these identifiers must be <code>camelCase</code> in Kotlin. For example, the metric defined in the <code>metrics.yaml</code> as:</p>
<pre><code class="language-YAML">views:
  login_opened:
    ...
</code></pre>
<p>is accessible in Kotlin as:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Views
Views.loginOpened...
</code></pre>
<h1><a class="header" href="#metric-parameters" id="metric-parameters">Metric parameters</a></h1>
<p>All metric types must include the following required parameters:</p>
<ul>
<li>
<p><code>description</code>: <strong>Required.</strong> A textual description of the metric for humans. It should describe what the metric does, what it means for analysts, and its edge cases or any other helpful information.</p>
</li>
<li>
<p><code>notification_emails</code>: <strong>Required.</strong> A list of email addresses to notify for important events with the metric or when people with context or ownership for the metric need to be contacted.</p>
</li>
<li>
<p><code>bugs</code>: <strong>Required.</strong> A list of bugs (e.g. Bugzilla or Github) that are relevant to this metric. For example, bugs that track its original implementation or later changes to it. If a number, it is an ID to an issue in the default tracker (<code>bugzilla.mozilla.org</code>). If a string, it must be a URI to a bug page in a tracker.</p>
</li>
<li>
<p><code>data_reviews</code>: <strong>Required.</strong> A list of URIs to any data collection reviews relevant to the metric.</p>
</li>
<li>
<p><code>expires</code>: <strong>Required.</strong> May be one of the following values:</p>
<ul>
<li><code>&lt;build date&gt;</code>: An ISO date <code>yyyy-mm-dd</code> in UTC on which the metric expires. For example, <code>2019-03-13</code>. This date is checked at build time. Except in special cases, this form should be used so that the metric automatically &quot;sunsets&quot; after a period of time.</li>
<li><code>never</code>: This metric never expires.</li>
<li><code>expired</code>: This metric is manually expired.</li>
</ul>
</li>
</ul>
<p>All metric types also support the following optional parameters:</p>
<ul>
<li>
<p><code>lifetime</code>: Defines the lifetime of the metric. Different lifetimes affect when the metrics value is reset.</p>
<ul>
<li><code>ping</code> (default): The metric is reset each time it is sent in a ping.</li>
<li><code>user</code>: The metric is part of the user's profile.</li>
<li><code>application</code>: The metric is related to an application run, and is reset when the application restarts.</li>
</ul>
</li>
<li>
<p><code>send_in_pings</code>: Defines which pings the metric should be sent on. If not specified, the metric is sent on the &quot;default ping&quot;, which is the <code>events</code> ping for events and the <code>metrics</code> ping for everything else. Most metrics don't need to specify this unless they are sent on custom pings.</p>
</li>
<li>
<p><code>disabled</code>: (default: <code>false</code>) Data collection for this metric is disabled.</p>
</li>
<li>
<p><code>version</code>: (default: 0) The version of the metric. A monotonically increasing integer value. This should be bumped if the metric changes in a backward-incompatible way.</p>
</li>
</ul>
<h1><a class="header" href="#unit-testing-glean-metrics" id="unit-testing-glean-metrics">Unit testing Glean metrics</a></h1>
<p>In order to support unit testing inside of client applications using the Glean SDK, a set of testing API functions have been included.
The intent is to make the Glean SDK easier to test 'out of the box' in any client application it may be used in.
These functions expose a way to inspect and validate recorded metric values within the client application but are restricted to test code only through visibility annotations (<code>@VisibleForTesting(otherwise = VisibleForTesting.NONE)</code>).</p>
<h2><a class="header" href="#general-test-api-method-semantics" id="general-test-api-method-semantics">General test API method semantics</a></h2>
<p>In order to prevent issues with async calls when unit testing Glean, it is important to put the Glean SDK into testing mode by calling <code>Glean.enableTestingMode()</code>.
This will ensure that metrics are done recording when the other test functions are used.</p>
<p>To check if a value exists (i.e. it has been recorded), there is a <code>testHasValue()</code> function on each of the metric instances:</p>
<pre><code class="language-kotlin">assertTrue(GleanMetrics.Foo.UriCount.testHasValue())
</code></pre>
<p>To check the actual values, there is a <code>testGetValue()</code> function on each of the metric instances.
This function will return a datatype appropriate to the specific type of the metric it is being used with:</p>
<pre><code class="language-kotlin">assertEquals(5, GleanMetrics.Foo.UriCount.testGetValue())
</code></pre>
<p>Note that each of these functions has it's visibility limited to the scope to only unit tests by making use of the <code>@VisibleForTesting</code> annotation, so the IDE should complain if you attempt to use them inside of client code.</p>
<h2><a class="header" href="#testing-metrics-for-custom-pings" id="testing-metrics-for-custom-pings">Testing metrics for custom pings</a></h2>
<p>In order to test metrics where the metric is included in more than one ping, the test functions take an optional <code>pingName</code> argument.
This is the name of the ping that the metric is being sent in, such as <code>events</code> for the &quot;events&quot; ping, or <code>metrics</code> for the &quot;metrics&quot; ping.
This could also be a custom ping name that the metric is being sent in.
In most cases you should not have to supply the ping name to the test function and can just use the default which is the &quot;default&quot; ping that this metric is sent in.
You should only need to provide a <code>pingName</code> if the metric is being sent in more than one ping in order to identify the correct metric store.</p>
<p>You can call the <code>testHasValue()</code> and <code>testGetValue()</code> functions with <code>pingName</code> like this:</p>
<pre><code class="language-kotlin">GleanMetrics.Foo.UriCount.testHasValue(&quot;customPing&quot;)
GleanMetrics.Foo.UriCount.testGetValue(&quot;customPing&quot;)
</code></pre>
<h2><a class="header" href="#example-of-using-the-test-api" id="example-of-using-the-test-api">Example of using the test API</a></h2>
<p>Here is a longer example to better illustrate the intended use of the test API:</p>
<pre><code class="language-kotlin">// Enable testing mode
// (Perhaps called from a @Before method so it precedes every test in the suite.)
Glean.enableTestingMode()

// Record a metric value with extra to validate against
GleanMetrics.BrowserEngagement.click.record(
    mapOf(
        BrowserEngagement.clickKeys.font to &quot;Courier&quot;
    )
)

// Record more events without extras attached
BrowserEngagement.click.record()
BrowserEngagement.click.record()

// Check if we collected any events into the 'click' metric
assertTrue(BrowserEngagement.click.testHasValue())

// Retrieve a snapshot of the recorded events
val events = BrowserEngagement.click.testGetValue()

// Check if we collected all 3 events in the snapshot
assertEquals(3, events.size)

// Check extra key/value for first event in the list
assertEquals(&quot;Courier&quot;, events.elementAt(0).extra[&quot;font&quot;])
</code></pre>
<h1><a class="header" href="#debugging-products-using-the-glean-sdk" id="debugging-products-using-the-glean-sdk">Debugging products using the Glean SDK</a></h1>
<p>The Glean SDK exports the <code>GleanDebugActivity</code> that can be used to toggle debugging features on or off. 
Users can invoke this special activity, at run-time, using the following <a href="https://developer.android.com/studio/command-line/adb"><code>adb</code></a> command:</p>
<p><code>adb shell am start -n [applicationId]/mozilla.components.service.glean.debug.GleanDebugActivity [extra keys]</code></p>
<p>In the above:</p>
<ul>
<li>
<p><code>[applicationId]</code> is the product's application id as defined in the manifest file and/or build script. For the Glean sample application, this is <code>org.mozilla.samples.glean</code> for a release build and <code>org.mozilla.samples.glean.debug</code> for a debug build.</p>
</li>
<li>
<p><code>[extra keys]</code> is a list of extra keys to be passed to the debug activity. See the <a href="https://developer.android.com/studio/command-line/adb#IntentSpec">documentation</a> for the command line switches used to pass the extra keys. 
These are the currently supported keys:</p>
</li>
</ul>
<table><thead><tr><th>key</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td>logPings</td><td>boolean (--ez)</td><td>If set to <code>true</code>, pings are dumped to logcat; defaults to <code>false</code></td></tr>
<tr><td>sendPing</td><td>string (--es)</td><td>Sends the ping with the given name immediately</td></tr>
<tr><td>tagPings</td><td>string (--es)</td><td>Tags all outgoing pings as debug pings to make them available for real-time validation. The value must match the pattern <code>[a-zA-Z0-9-]{1,20}</code></td></tr>
</tbody></table>
<p>For example, to direct a release build of the Glean sample application to (1) dump pings to logcat, (2) tag the ping with the <code>test-metrics-ping</code> tag, and (3) send the &quot;metrics&quot; ping immediately, the following command can be used:</p>
<pre><code>adb shell am start -n org.mozilla.samples.glean/mozilla.components.service.glean.debug.GleanDebugActivity \
  --ez logPings true \
  --es sendPing metrics \
  --es tagPings test-metrics-ping
</code></pre>
<h3><a class="header" href="#important-gleandebugactivity-notes" id="important-gleandebugactivity-notes">Important GleanDebugActivity notes!</a></h3>
<ul>
<li>
<p>Options that are set using the adb flags are not immediately reset and will persist until the application is closed or manually reset.</p>
</li>
<li>
<p>There are a couple different ways in which to send pings through the GleanDebugActivity.</p>
<ol>
<li>You can use the <code>GleanDebugActivity</code> in order to tag pings and trigger them manually using the UI.  This should always produce a ping with all required fields.</li>
<li>You can use the <code>GleanDebugActivity</code> to tag <em>and</em> send pings.  This has the side effect of potentially sending a ping which does not include all fields because <code>sendPings</code> triggers pings to be sent before certain application behaviors can occur which would record that information.  For example, <code>duration</code> is not calculated or included in a baseline ping sent with <code>sendPing</code> because it forces the ping to be sent before the <code>duration</code> metric has been recorded.</li>
</ol>
</li>
</ul>
<h1><a class="header" href="#error-reporting" id="error-reporting">Error reporting</a></h1>
<p>The Glean SDK records the number of errors that occur when metrics are passed invalid data or are otherwise used incorrectly. 
This information is reported back in special labeled counter metrics in the <code>glean.error</code> category. 
Error metrics are included in the same pings as the metric that caused the error. 
Additionally, error metrics are always sent in the <a href="user/pings/metrics.html"><code>metrics</code> ping</a> ping.</p>
<p>The following categories of errors are recorded:</p>
<ul>
<li><code>invalid_value</code>: The metric value was invalid or out-of-range.</li>
<li><code>invalid_label</code>: The label on a labeled metric was invalid.</li>
</ul>
<p>For example, if you had a string metric and passed it a string that was too long:</p>
<pre><code class="language-Kotlin">MyMetrics.stringMetric.set(&quot;this_string_is_longer_than_the_limit_for_string_metrics&quot;)
</code></pre>
<p>The following error metric counter would be incremented:</p>
<pre><code class="language-Kotlin">Glean.error.invalidValue.add(1)
</code></pre>
<p>Resulting in the following keys in the ping:</p>
<pre><code class="language-json">{
  &quot;metrics&quot;: {
    &quot;labeled_counter&quot;: {
      &quot;glean.error.invalid_value&quot;: {
        &quot;my_metrics.string_metric&quot;: 1
      }
    }
  }
}
</code></pre>
<p>If you have a debug build of the Glean SDK, details about the errors being recorded are included in the logs. This detailed information is not included in Glean pings.</p>
<h1><a class="header" href="#metrics" id="metrics">Metrics</a></h1>
<p>There are different metrics to choose from, depending on what you want to achieve:</p>
<ul>
<li>
<p><a href="user/metrics/event.html">Events</a>: Records events e.g. individual occurences of user actions, say every time a view was open and from where.</p>
</li>
<li>
<p><a href="user/metrics/boolean.html">Boolean</a>: Records a single truth value, for example &quot;is a11y enabled?&quot;</p>
</li>
<li>
<p><a href="user/metrics/string.html">String</a>: Records a single Unicode string value, for example the name of the OS.</p>
</li>
<li>
<p><a href="user/metrics/labeled_strings.html">Labeled strings</a>: Records multiple Unicode string values, for example to record which kind of error occurred in different stages of a login process.</p>
</li>
<li>
<p><a href="user/metrics/string_list.html">String List</a>: Records a list of Unicode string values, for example the list of enabled search engines.</p>
</li>
<li>
<p><a href="user/metrics/counter.html">Counter</a>: Used to count how often something happens, for example, how often a certain button was pressed.</p>
</li>
<li>
<p><a href="user/metrics/labeled_counters.html">Labeled counter</a>: Used to count how often something happens, for example which kind of crash occurred (<code>&quot;uncaught_exception&quot;</code> or <code>&quot;native_code_crash&quot;</code>).</p>
</li>
<li>
<p><a href="user/metrics/timespan.html">Timespan</a>: Used to measure how much time is spent in a single task.</p>
</li>
<li>
<p><a href="user/metrics/labeled_timespans.html">Labeled timespans</a>: Used to measure how much time is spent in a set of related tasks, for example different stages in a login process (the time take for <code>&quot;fill_form&quot;</code>, <code>&quot;auth_with_server&quot;</code>, <code>&quot;load_next_view&quot;</code>).</p>
</li>
<li>
<p><a href="user/metrics/timing_distribution.html">Timing Distribution</a>: Used to record the distribution of multiple time measurements.</p>
</li>
<li>
<p><a href="user/metrics/datetime.html">Datetime</a>: Used to record an absolute date and time, such as the time the user first ran the application.</p>
</li>
<li>
<p><a href="user/metrics/uuid.html">UUID</a>: Used to record universally unique identifiers (UUIDs), such as a client ID.</p>
</li>
</ul>
<h2><a class="header" href="#labeled-metrics" id="labeled-metrics">Labeled metrics</a></h2>
<p>There are two types of metrics listed above - <em>labeled</em> and <em>unlabeled</em> metrics. If a metric is <em>labeled</em>, it means that for a single metric entry you define in <code>metrics.yaml</code>, you can record into multiple metrics under the same name, each of the same type and identified by a different string label.</p>
<p>This is useful when you need to break down metrics by a label known at build time or run time. For example:</p>
<ul>
<li>
<p>When you want to count a different set of subviews that users interact with, you could use <code>viewCount[&quot;view1&quot;].add()</code> and <code>viewCount[&quot;view2&quot;].add()</code>.</p>
</li>
<li>
<p>When you want to count errors that might occur for a feature, you could use <code>errorCount[errorName].add()</code>.</p>
</li>
</ul>
<p>Labeled metrics come in two forms:</p>
<ul>
<li>
<p><strong>Static labels</strong>: The labels are specified at build time in the <code>metrics.yaml</code> file.
If a label that isn't part of this set is used at run time, it is converted to the special label <code>__other__</code>.</p>
</li>
<li>
<p><strong>Dynamic labels</strong>: The labels aren't known at build time, so are set at run time.
Only the first 16 labels seen by the Glean SDK will be tracked. After that, any additional labels are converted to the special label <code>__other__</code>.</p>
</li>
</ul>
<hr />
<p><em>Note:</em> Be careful with using arbitrary strings as labels and make sure they can't accidentally contain identifying data (like directory paths or user input).</p>
<hr />
<h1><a class="header" href="#boolean" id="boolean">Boolean</a></h1>
<p>Booleans are used for simple flags, for example &quot;is a11y enabled&quot;?.</p>
<h2><a class="header" href="#configuration" id="configuration">Configuration</a></h2>
<p>Say you're adding a boolean to record whether a11y is enabled on the device. First you need to add an entry for the boolean to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">flags:
  a11y_enabled:
    type: boolean
    description: &gt;
      Records whether a11y is enabled on the device.
    ...
</code></pre>
<h2><a class="header" href="#api" id="api">API</a></h2>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Flags

Flags.a11yEnabled.set(System.isAccesibilityEnabled())
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Flags
Glean.enableTestingMode()

// Was anything recorded?
assertTrue(Flags.a11yEnabled.testHasValue())
// Does it have the expected value?
assertTrue(Flags.a11yEnabled.testGetValue())
</code></pre>
<h2><a class="header" href="#limits" id="limits">Limits</a></h2>
<ul>
<li>None.</li>
</ul>
<h2><a class="header" href="#examples" id="examples">Examples</a></h2>
<ul>
<li>Is a11y enabled?</li>
</ul>
<h2><a class="header" href="#recorded-errors" id="recorded-errors">Recorded errors</a></h2>
<ul>
<li>None.</li>
</ul>
<h2><a class="header" href="#reference" id="reference">Reference</a></h2>
<ul>
<li><a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-boolean-metric-type/index.html">Kotlin API docs</a></li>
</ul>
<h1><a class="header" href="#counter" id="counter">Counter</a></h1>
<p>Used to count how often something happens, say how often a certain button was pressed. A counter always starts from <code>0</code>. Each time you record to a counter, its value is incremented.</p>
<h2><a class="header" href="#configuration-1" id="configuration-1">Configuration</a></h2>
<p>Say you're adding a new counter for how often the refresh button is pressed. First you need to add an entry for the counter to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">controls:
  refresh_pressed:
    type: counter
    description: &gt;
      Counts how often the refresh button is pressed.
    ...
</code></pre>
<h2><a class="header" href="#api-1" id="api-1">API</a></h2>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Controls

Controls.refreshPressed.add() // Adds 1 to the counter.
Controls.refreshPressed.add(5) // Adds 5 to the counter.
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Controls
Glean.enableTestingMode()

// Was anything recorded?
assertTrue(Controls.refreshPressed.testHasValue())
// Does the counter have the expected value?
assertEquals(6, Controls.refreshPressed.testGetValue())
</code></pre>
<h2><a class="header" href="#limits-1" id="limits-1">Limits</a></h2>
<ul>
<li>Only increments, saturates at the limits of a 32-bit signed integer.</li>
</ul>
<h2><a class="header" href="#examples-1" id="examples-1">Examples</a></h2>
<ul>
<li>How often a certain button was pressed?</li>
</ul>
<h2><a class="header" href="#recorded-errors-1" id="recorded-errors-1">Recorded errors</a></h2>
<ul>
<li>None.</li>
</ul>
<h2><a class="header" href="#reference-1" id="reference-1">Reference</a></h2>
<ul>
<li><a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-counter-metric-type/index.html">Kotlin API docs</a></li>
</ul>
<h1><a class="header" href="#labeled-counters" id="labeled-counters">Labeled Counters</a></h1>
<p>Labeled counters are used to record different related counts that should sum up to a total.</p>
<h2><a class="header" href="#configuration-2" id="configuration-2">Configuration</a></h2>
<p>For example, you may want to record a count of different types of crashes for your Android application, such as native code crashes and uncaught exceptions:</p>
<pre><code class="language-YAML">stability:
  crash_count:
    type: labeled_counter
    description: &gt;
      Counts the number of crashes that occur in the application. ...
    labels:
      - uncaught_exception
      - native_code_crash
    ...
</code></pre>
<h2><a class="header" href="#api-2" id="api-2">API</a></h2>
<p>Now you can use the labeled counter from the application's code:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Stability
Stability.crashCount[&quot;uncaught_exception&quot;].add() // Adds 1 to the &quot;uncaught_exception&quot; counter.
Stability.crashCount[&quot;native_code_crash&quot;].add(3) // Adds 3 to the &quot;native_code_crash&quot; counter.
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Stability
Glean.enableTestingMode()
// Was anything recorded?
assertTrue(Stability.crashCount[&quot;uncaught_exception&quot;].testHasValue())
assertTrue(Stability.crashCount[&quot;native_code_crash&quot;].testHasValue())
// Do the counters have the expected values?
assertEquals(1, Stability.crashCount[&quot;uncaught_exception&quot;].testGetValue())
assertEquals(3, Stability.crashCount[&quot;native_code_crash&quot;].testGetValue())
</code></pre>
<h2><a class="header" href="#limits-2" id="limits-2">Limits</a></h2>
<ul>
<li>
<p>Labels support lowercase alphanumeric characters; they additionally allow for dots (<code>.</code>), underscores (<code>_</code>) and/or hyphens (<code>-</code>).</p>
</li>
<li>
<p>Labels are limited to starting with either a letter or an underscore character.</p>
</li>
<li>
<p>Each label must have a maximum of 60 characters.</p>
</li>
<li>
<p>If the labels are specified in the <code>metrics.yaml</code>, using a different label will be replaced with the special value <code>__other__</code>.</p>
</li>
<li>
<p>If the labels aren't specified in the <code>metrics.yaml</code>, only 16 different dynamic labels may be used, after which the special value <code>__other__</code> will be used.</p>
</li>
</ul>
<h2><a class="header" href="#examples-2" id="examples-2">Examples</a></h2>
<ul>
<li>Record the number of times different kinds of crashes occurred.</li>
</ul>
<h2><a class="header" href="#recorded-errors-2" id="recorded-errors-2">Recorded Errors</a></h2>
<ul>
<li>
<p><code>invalid_label</code>: If the label contains invalid characters.</p>
</li>
<li>
<p><code>invalid_label</code>: If the label exceeds the maximum number of allowed characters.</p>
</li>
</ul>
<h2><a class="header" href="#reference-2" id="reference-2">Reference</a></h2>
<ul>
<li>Kotlin API docs <a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-labeled-metric-type/index.html">LabeledMetricType</a>, <a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-counter-metric-type/index.html">CounterMetricType</a></li>
</ul>
<h1><a class="header" href="#strings" id="strings">Strings</a></h1>
<p>This allows recording a Unicode string value with arbitrary content.</p>
<hr />
<p><em>Note:</em> Be careful using arbitrary strings and make sure they can't accidentally contain identifying data (like directory paths or user input).</p>
<hr />
<p><em>Note:</em> This is does not support recording JSON blobs - please get in contact with the Telemetry team if you're missing a type.</p>
<hr />
<h2><a class="header" href="#configuration-3" id="configuration-3">Configuration</a></h2>
<p>Say you're adding a metric to find out what the default search in a browser is. First you need to add an entry for the metric to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">search.default:
  name:
    type: string
    description: &gt;
      The name of the default search engine.
    ...
</code></pre>
<h2><a class="header" href="#api-3" id="api-3">API</a></h2>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.SearchDefault

// Record a value into the metric.
SearchDefault.name.set(&quot;duck duck go&quot;)
// If it changed later, you can record the new value:
SearchDefault.name.set(&quot;wikipedia&quot;)
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.SearchDefault

Glean.enableTestingMode()
// Was anything recorded?
assertTrue(SearchDefault.name.testHasValue())
// Does the string metric have the expected value?
assertEquals(&quot;wikipedia&quot;, SearchDefault.name.testGetValue())
</code></pre>
<h2><a class="header" href="#limits-3" id="limits-3">Limits</a></h2>
<ul>
<li>Fixed maximum string length: 50. Longer strings are truncated. For the original Kotlin implementation of the Glean SDK, this is measured in Unicode characters. For the Rust implementation, this is measured in the number of bytes when the string is encoded in UTF-8.</li>
</ul>
<h2><a class="header" href="#examples-3" id="examples-3">Examples</a></h2>
<ul>
<li>
<p>Record the operating system name with a value of &quot;android&quot;.</p>
</li>
<li>
<p>Recording the device model with a value of &quot;SAMSUNG-SGH-I997&quot;.</p>
</li>
</ul>
<h2><a class="header" href="#recorded-errors-3" id="recorded-errors-3">Recorded errors</a></h2>
<ul>
<li><code>invalid_value</code>: if the string is too long</li>
</ul>
<h2><a class="header" href="#reference-3" id="reference-3">Reference</a></h2>
<ul>
<li><a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-string-metric-type/index.html">Kotlin API docs</a>.</li>
</ul>
<h1><a class="header" href="#labeled-strings" id="labeled-strings">Labeled Strings</a></h1>
<p>Labeled strings record multiple Unicode string values, each under a different label.</p>
<h2><a class="header" href="#configuration-4" id="configuration-4">Configuration</a></h2>
<p>For example to record which kind of error occured in different stages of a login process - <code>&quot;RuntimeException&quot;</code> in the <code>&quot;server_auth&quot;</code> stage or <code>&quot;invalid_string&quot;</code> in the <code>&quot;enter_email&quot;</code> stage:</p>
<pre><code class="language-YAML">login:
  errors_by_stage:
    type: labeled_string
    description: Records the error type, if any, that occur in different stages of the login process.
    labels:
      - server_auth
      - enter_email
    ...
</code></pre>
<h2><a class="header" href="#api-4" id="api-4">API</a></h2>
<p>Now you can use the labeled string from the application's code:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Login

Login.errorsByStage[&quot;server_auth&quot;].set(&quot;Invalid password&quot;)
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Login
Glean.enableTestingMode()

// Was anything recorded?
assertTrue(Login.errorsByStage[&quot;server_auth&quot;].testHasValue())
</code></pre>
<h2><a class="header" href="#limits-4" id="limits-4">Limits</a></h2>
<ul>
<li>
<p>Labels support lowercase alphanumeric characters; they additionally allow for dots (<code>.</code>), underscores (<code>_</code>) and/or hyphens (<code>-</code>).</p>
</li>
<li>
<p>Labels are limited to starting with either a letter or an underscore character.</p>
</li>
<li>
<p>Each label must have a maximum of 60 characters.</p>
</li>
<li>
<p>If the labels are specified in the <code>metrics.yaml</code>, using a different label will be replaced with the special value <code>__other__</code>.</p>
</li>
<li>
<p>If the labels aren't specified in the <code>metrics.yaml</code>, only 16 different dynamic labels may be used, after which the special value <code>__other__</code> will be used.</p>
</li>
</ul>
<h2><a class="header" href="#examples-4" id="examples-4">Examples</a></h2>
<ul>
<li>What kind of errors occurred at each step in the login process? </li>
</ul>
<h2><a class="header" href="#recorded-errors-4" id="recorded-errors-4">Recorded Errors</a></h2>
<ul>
<li>
<p><code>invalid_label</code>: If the label contains invalid characters.</p>
</li>
<li>
<p><code>invalid_label</code>: If the label exceeds the maximum number of allowed characters.</p>
</li>
</ul>
<h2><a class="header" href="#reference-4" id="reference-4">Reference</a></h2>
<ul>
<li>Kotlin API docs: <a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-labeled-metric-type/index.html">LabeledMetricType</a>, <a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-string-metric-type/index.html">StringMetricType</a></li>
</ul>
<h1><a class="header" href="#string-list" id="string-list">String List</a></h1>
<p>Strings lists are used for recording a list of Unicode string values, such as the names of the enabled search engines.</p>
<hr />
<p><em>Note:</em> Be careful using arbitrary strings and make sure they can't accidentally contain identifying data (like directory paths or user input).</p>
<hr />
<h2><a class="header" href="#configuration-5" id="configuration-5">Configuration</a></h2>
<p>First you need to add an entry for the counter to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">search:
  engines:
    type: string_list
    description: &gt;
      Records the name of the enabled search engines.
    ...
</code></pre>
<h2><a class="header" href="#api-5" id="api-5">API</a></h2>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Search

// Add them one at a time
engines.forEach {
  Search.engines.add(it)
}

// Set them in one go
Search.engines.set(engines)
</code></pre>
<p>There are test APIs available too:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Search
Glean.enableTestingMode()

// Was anything recorded?
assertTrue(Search.engines.testHasValue())
// Does it have the expected value?
assertEquals(listOf(&quot;Google&quot;, &quot;DuckDuckGo&quot;), Search.engines.testGetValue())
</code></pre>
<h2><a class="header" href="#limits-5" id="limits-5">Limits</a></h2>
<ul>
<li>
<p>Fixed maximum string length: 50. Longer strings are truncated. For the original Kotlin implementation of the Glean SDK, this is measured in Unicode characters. For the Rust implementation, this is measured in the number of bytes when the string is encoded in UTF-8.</p>
</li>
<li>
<p>Fixed maximum list length: 20 items. Additional strings are dropped.</p>
</li>
</ul>
<h2><a class="header" href="#examples-5" id="examples-5">Examples</a></h2>
<ul>
<li>The names of the enabled search engines.</li>
</ul>
<h2><a class="header" href="#recorded-errors-5" id="recorded-errors-5">Recorded errors</a></h2>
<ul>
<li>
<p><code>invalid_value</code>: if the string is too long</p>
</li>
<li>
<p><code>invalid_value</code>: if the list is too long</p>
</li>
</ul>
<h2><a class="header" href="#reference-5" id="reference-5">Reference</a></h2>
<ul>
<li><a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-string-list-metric-type/index.html">Kotlin API docs</a></li>
</ul>
<h1><a class="header" href="#timespan" id="timespan">Timespan</a></h1>
<p>Timespans are used to make a measurement of how much time is spent in a particular task.</p>
<p>To measure the distribution of multiple timespans, see <a href="user/metrics/timing_distribution.html">Timing Distributions</a>. To record absolute times, see <a href="user/metrics/datetime.html">Datetimes</a>.</p>
<h2><a class="header" href="#configuration-6" id="configuration-6">Configuration</a></h2>
<p>Timespans have a required <code>time_unit</code> parameter to specify the smallest unit of resolution that the timespan will record. The allowed values for <code>time_unit</code> are:</p>
<ul>
<li><code>nanosecond</code></li>
<li><code>microsecond</code></li>
<li><code>millisecond</code></li>
<li><code>second</code></li>
<li><code>minute</code></li>
<li><code>hour</code></li>
<li><code>day</code></li>
</ul>
<p>Consider the resolution that is required by your metric, and use the largest possible value that will provide useful information so as to not leak too much fine-grained information from the client. It is important to note that the value sent in the ping is truncated down to the nearest unit. Therefore, a measurement of 500 nanoseconds will be truncated to 0 microseconds.</p>
<p>Say you're adding a new timespan for the time spent logging into the app. First you need to add an entry for the counter to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">auth:
  login_time:
    type: timespan
    description: &gt;
      Measures the time spent logging in.
    time_unit: milliseconds
    ...
</code></pre>
<h2><a class="header" href="#api-6" id="api-6">API</a></h2>
<p>Each time interval that the timespan metric records must be associated with an object provided by the user. This is so that intervals can be measured concurrently. In our example using login time, this might be an object representing the login UI page.</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Auth

fun onShowLogin(e: Event) {
    Auth.loginTime.start()
    // ...
}

fun onLogin(e: Event) {
    Auth.loginTime.stop()
    // ...
}

fun onLoginCancel(e: Event) {
    Auth.loginTime.cancel()
    // ...
}
</code></pre>
<p>The time reported in the telemetry ping will be timespan recorded during the lifetime of the ping.</p>
<p>There are test APIs available too:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Auth
Glean.enableTestingMode()

// Was anything recorded?
assertTrue(Auth.loginTime.testHasValue())
// Does the timer have the expected value
assertTrue(Auth.loginTime.testGetValue() &gt; 0)
</code></pre>
<h3><a class="header" href="#raw-api" id="raw-api">Raw API</a></h3>
<blockquote>
<p><strong>Note</strong>: The raw API was designed to support a specific set of use-cases.
Please consider using the higher level APIs listed above.</p>
</blockquote>
<p>It's possible to explicitly set the timespan value, in nanoseconds.
This API should only be used if your library or application requires recording times in a way that can not make use of <code>start</code>/<code>stop</code>/<code>cancel</code>.</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.HistorySync

val duration = SyncResult.status.syncs.took.toLong()
HistorySync.setRawNanos(duration)
</code></pre>
<p>The raw API will not overwrite a running timer or existing timespan value.</p>
<h2><a class="header" href="#limits-6" id="limits-6">Limits</a></h2>
<ul>
<li>None.</li>
</ul>
<h2><a class="header" href="#examples-6" id="examples-6">Examples</a></h2>
<ul>
<li>How much time is spent rendering the UI?</li>
</ul>
<h2><a class="header" href="#recorded-errors-6" id="recorded-errors-6">Recorded errors</a></h2>
<ul>
<li><code>invalid_value</code>
<ul>
<li>If recording a negative timespan.</li>
<li>If starting a timer while a previous timer is running.</li>
<li>If stopping a timer while it is not running.</li>
<li>If trying to set a raw timespan while a timer is running.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#reference-6" id="reference-6">Reference</a></h2>
<ul>
<li><a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-timespan-metric-type/index.html">Kotlin API docs</a></li>
</ul>
<h1><a class="header" href="#labeled-timespans" id="labeled-timespans">Labeled Timespans</a></h1>
<p>Used to measure how much time is spent in a set of related tasks.</p>
<h2><a class="header" href="#configuration-7" id="configuration-7">Configuration</a></h2>
<p>For example, to record the time spent in different stages in a login process:</p>
<pre><code class="language-YAML">auth:
  times_per_stage:
    type: labeled_timespan
    description: The time spent in the different stages of the login process.
    labels:
      - fill_form
      - auth_with_server
      - load_next_view
    ...
</code></pre>
<h2><a class="header" href="#api-7" id="api-7">API</a></h2>
<p>Now you can use the labeled timespan from the application's code. 
Each time interval that the metric records must be associated with an object provided by the user. 
This is so that intervals can be measured concurrently. 
In our example, using time in different stages of the login process, this might be an object representing the login UI page.</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Auth
fun onShowLoginForm(e: Event) {
    Auth.timesPerStage[&quot;fill_form&quot;].start(e.target)
    // ...
}
fun onLoginFormSubmitted(e: Event) {
    Auth.timesPerStage[&quot;fill_form&quot;].stopAndSum(e.target)
    Auth.timesPerStage[&quot;auth_with_server&quot;].start(e.target)
    // ...
}
// ... etc.
fun onLoginCancel(e: Event) {
    Auth.timesPerStage[&quot;fill_form&quot;].cancel(e.target)
    // ...
}
</code></pre>
<p>The times reported in the Glean ping will be the sum of all of these timespans recorded during the lifetime of the ping.</p>
<p>There are test APIs available too:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Auth
Glean.enableTestingMode()
// Was anything recorded?
assertTrue(Auth.timesPerStage[&quot;fill_form&quot;].testHasValue())
assertTrue(Auth.timesPerStage[&quot;auth_with_server&quot;].testHasValue())
// Does the timer have the expected value
assertTrue(Auth.timesPerStage[&quot;fill_form&quot;].testGetValue() &gt; 0)
assertTrue(Auth.timesPerStage[&quot;auth_with_server&quot;].testGetValue() &gt; 0)Now you can use the labeled counter from the application's code:
</code></pre>
<h2><a class="header" href="#limits-7" id="limits-7">Limits</a></h2>
<ul>
<li>
<p>Labels support lowercase alphanumeric characters; they additionally allow for dots (<code>.</code>), underscores (<code>_</code>) and/or hyphens (<code>-</code>).</p>
</li>
<li>
<p>Labels are limited to starting with either a letter or an underscore character.</p>
</li>
<li>
<p>Each label must have a maximum of 60 characters.</p>
</li>
<li>
<p>If the labels are specified in the <code>metrics.yaml</code>, using a different label will be replaced with the special value <code>__other__</code>.</p>
</li>
<li>
<p>If the labels aren't specified in the <code>metrics.yaml</code>, only 16 different dynamic labels may be used, after which the special value <code>__other__</code> will be used.</p>
</li>
</ul>
<h2><a class="header" href="#examples-7" id="examples-7">Examples</a></h2>
<ul>
<li>Record the time spent in different stages in a login process.</li>
</ul>
<h2><a class="header" href="#recorded-errors-7" id="recorded-errors-7">Recorded Errors</a></h2>
<ul>
<li>
<p><code>invalid_label</code>: If the label contains invalid characters.</p>
</li>
<li>
<p><code>invalid_label</code>: If the label exceeds the maximum number of allowed characters.</p>
</li>
</ul>
<h2><a class="header" href="#reference-7" id="reference-7">Reference</a></h2>
<ul>
<li>Kotlin API docs <a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-labeled-metric-type/index.html">LabeledMetricType</a>, <a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-timespan-metric-type/index.html">TimespanMetricType</a></li>
</ul>
<h1><a class="header" href="#timing-distribution" id="timing-distribution">Timing Distribution</a></h1>
<p>Timing distributions are used to accumulate and store time measurement, for analyzing distributions of the timing data.</p>
<p>To measure the distribution of multiple timespans, see <a href="user/metrics/timing_distribution.html">Timing Distributions</a>. To record absolute times, see <a href="user/metrics/datetime.html">Datetimes</a>.</p>
<h2><a class="header" href="#configuration-8" id="configuration-8">Configuration</a></h2>
<p>Timing distributions have a required <code>time_unit</code> parameter to specify the resolution and range of the values that are recorded. The allowed values for <code>time_unit</code> are:</p>
<ul>
<li><code>nanosecond</code></li>
<li><code>microsecond</code></li>
<li><code>millisecond</code></li>
<li><code>second</code></li>
<li><code>minute</code></li>
<li><code>hour</code></li>
<li><code>day</code></li>
</ul>
<p>Which range of values is recorded in detail depends on the <code>time_unit</code>, e.g. for milliseconds, all values greater 60000 are recorded as overflow values.</p>
<p>If you wanted to create a timing distribution to measure page load times, first you need to add an entry for it to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">pages:
  page_load:
    type: timing_distribution
    time_unit: millisecond
    description: &gt;
      Counts how long each page takes to load
    ...
</code></pre>
<h2><a class="header" href="#api-8" id="api-8">API</a></h2>
<p>Now you can use the timing distribution from the application's code.
Starting a timer returns a timer ID that needs to be used to stop or cancel the timer at a later point.
Multiple intervals can be measured concurrently.
For example, to measure page load time on a number of tabs that are loading at the same time, each tab object needs to store the running timer ID.</p>
<pre><code class="language-Kotlin">import mozilla.components.service.glean.timing.GleanTimerId
import org.mozilla.yourApplication.GleanMetrics.Pages

val timerId : GleanTimerId

fun onPageStart(e: Event) {
    timerId = Pages.pageLoad.start()
}

fun onPageLoaded(e: Event) {
    Pages.pageLoad.stopAndAccumulate(timerId)
}
</code></pre>
<p>There are test APIs available too.  For convenience, properties <code>sum</code> and <code>count</code> are exposed to facilitate validating that data was recorded correctly.</p>
<p>Continuing the <code>pageLoad</code> example above, at this point the metric should have a <code>sum == 11</code> and a <code>count == 2</code>:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Pages
Glean.enableTestingMode()

// Was anything recorded?
assertTrue(pages.pageLoad.testHasValue())

// Get snapshot
val snapshot = pages.pageLoad.testGetValue()

// Does the sum have the expected value?
assertEquals(11, snapshot.sum)

// Usually you don't know the exact timing values, but how many should have been recorded.
assertEquals(2L, snapshot.count())
</code></pre>
<h2><a class="header" href="#limits-8" id="limits-8">Limits</a></h2>
<ul>
<li>Which range of values is recorded in detail depends on the <code>time_unit</code>, e.g. for milliseconds, all values greater 60000 are recorded as overflow values.</li>
</ul>
<h2><a class="header" href="#examples-8" id="examples-8">Examples</a></h2>
<ul>
<li>How long does it take a page to load?</li>
</ul>
<h2><a class="header" href="#recorded-errors-8" id="recorded-errors-8">Recorded errors</a></h2>
<ul>
<li><code>invalid_value</code>: If recording a negative timespan.</li>
<li><code>invalid_value</code>: If a non-existing/stopped timer is stopped again.</li>
</ul>
<h2><a class="header" href="#reference-8" id="reference-8">Reference</a></h2>
<ul>
<li>See <a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-timing-distribution-metric-type/index.html">Kotlin API docs</a></li>
</ul>
<h1><a class="header" href="#uuid" id="uuid">UUID</a></h1>
<p>UUIDs are used to record values that uniquely identify some entity, such as a client id.</p>
<h2><a class="header" href="#configuration-9" id="configuration-9">Configuration</a></h2>
<p>You first need to add an entry for it to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">user:
  client_id:
    type: uuid
    description: &gt;
      A unique identifier for the client's profile
    ...
</code></pre>
<h2><a class="header" href="#api-9" id="api-9">API</a></h2>
<p>Now that the UUID is defined in <code>metrics.yaml</code>, you can use the metric to record values in the application's code.</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.User

User.clientId.generateAndSet() // Generate a new UUID and record it
User.clientId.set(UUID.randomUUID())  // Set a UUID explicitly
</code></pre>
<p>There are test APIs available too.</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.User
Glean.enableTestingMode()

// Was anything recorded?
assertTrue(User.clientId.testHasValue())
// Was it the expected value? 
assertEquals(uuid, User.clientId.testGetValue())
</code></pre>
<h2><a class="header" href="#limits-9" id="limits-9">Limits</a></h2>
<ul>
<li>None.</li>
</ul>
<h2><a class="header" href="#examples-9" id="examples-9">Examples</a></h2>
<ul>
<li>A unique identifier for the client.</li>
</ul>
<h2><a class="header" href="#recorded-errors-9" id="recorded-errors-9">Recorded errors</a></h2>
<ul>
<li>None.</li>
</ul>
<h2><a class="header" href="#reference-9" id="reference-9">Reference</a></h2>
<ul>
<li>See <a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-uuid-metric-type/index.html">Kotlin API docs</a>.</li>
</ul>
<h1><a class="header" href="#datetime" id="datetime">Datetime</a></h1>
<p>Datetimes are used to record an absolute date and time, for example the date and time that the application was first run.</p>
<p>The device's offset from UTC is recorded and sent with the datetime value in the ping.</p>
<p>To measure the distribution of multiple timespans, see <a href="user/metrics/timing_distribution.html">Timing Distributions</a>. To record absolute times, see <a href="user/metrics/datetime.html">Datetimes</a>.</p>
<h2><a class="header" href="#configuration-10" id="configuration-10">Configuration</a></h2>
<p>Datetimes have a required <code>time_unit</code> parameter to specify the smallest unit of resolution that the timespan will record. The allowed values for <code>time_unit</code> are:</p>
<ul>
<li><code>nanosecond</code></li>
<li><code>microsecond</code></li>
<li><code>millisecond</code></li>
<li><code>second</code></li>
<li><code>minute</code></li>
<li><code>hour</code></li>
<li><code>day</code></li>
</ul>
<p>Carefully consider the required resolution for recording your metric, and choose the coarsest resolution possible.</p>
<p>You first need to add an entry for it to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">install:
  first_run:
    type: datetime 
    time_unit: day 
    description: &gt;
      Records the date when the application was first run
    ...
</code></pre>
<h2><a class="header" href="#api-10" id="api-10">API</a></h2>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Install

Install.firstRun.set() // Records &quot;now&quot;
Install.firstRun.set(Calendar(2019, 3, 25)) // Records a custom datetime
</code></pre>
<p>There are test APIs available too.</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Install
Glean.enableTestingMode()

// Was anything recorded?
assertTrue(Install.firstRun.testHasValue())
// Was it the expected value?
// NOTE: Datetimes always include a timezone offset from UTC, hence the 
// &quot;-05:00&quot; suffix.
assertEquals(&quot;2019-03-25-05:00&quot;, Install.firstRun.testGetValueAsString())
</code></pre>
<h2><a class="header" href="#limits-10" id="limits-10">Limits</a></h2>
<ul>
<li>None.</li>
</ul>
<h2><a class="header" href="#examples-10" id="examples-10">Examples</a></h2>
<ul>
<li>When did the user first run the application?</li>
</ul>
<h2><a class="header" href="#recorded-errors-10" id="recorded-errors-10">Recorded errors</a></h2>
<ul>
<li>None.</li>
</ul>
<h2><a class="header" href="#reference-10" id="reference-10">Reference</a></h2>
<ul>
<li><a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-datetime-metric-type/index.html">Kotlin API docs</a></li>
</ul>
<h1><a class="header" href="#events" id="events">Events</a></h1>
<p>Events allow recording of e.g. individual occurences of user actions, say every time a view was open and from where. Each time you record an event, it records a
timestamp, the event's name and a set of custom values.</p>
<h2><a class="header" href="#configuration-11" id="configuration-11">Configuration</a></h2>
<p>Say you're adding a new event for when a view is shown. First you need to add an entry for the event to the <code>metrics.yaml</code> file:</p>
<pre><code class="language-YAML">views:
  login_opened:
    type: event
    description: &gt;
      Recorded when the login view is opened.
    ...
    extra_keys:
      source_of_login: 
        description: The source from which the login view was opened, e.g. &quot;toolbar&quot;.
</code></pre>
<h2><a class="header" href="#api-11" id="api-11">API</a></h2>
<p>Note that an <code>enum</code> has been generated for handling the <code>extra_keys</code>: it has the same name as the event metric, with <code>Keys</code> added.</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Views

Views.loginOpened.record(mapOf(Views.loginOpenedKeys.sourceOfLogin to &quot;toolbar&quot;))
</code></pre>
<p>There are test APIs available too, for example:</p>
<pre><code class="language-Kotlin">import org.mozilla.yourApplication.GleanMetrics.Views
Glean.enableTestingMode()

// Was any event recorded?
assertTrue(Views.loginOpened.testHasValue())
// Get a List of the recorded events.
val snapshot = Views.loginOpened.testGetValue()
// Check that two events were recorded.
assertEquals(2, snapshot.size)
val first = snapshot.single()
assertEquals(&quot;login_opened&quot;, first.name)
</code></pre>
<h2><a class="header" href="#limits-11" id="limits-11">Limits</a></h2>
<ul>
<li>
<p>When 500 events are queued on the client, and events pings is immediately sent.</p>
</li>
<li>
<p>Event timestamps use a system timer that is guaranteed to be monotonic only within a particular boot of the device. Therefore, if there are any unsent recorded events on disk when the application starts, any pings containing those events are sent immediately, so that the Glean SDK can start over using a new timer and events based on different timers are never sent within the same ping.</p>
</li>
</ul>
<h2><a class="header" href="#examples-11" id="examples-11">Examples</a></h2>
<ul>
<li>Every time a new tab is opened.</li>
</ul>
<h2><a class="header" href="#recorded-errors-11" id="recorded-errors-11">Recorded errors</a></h2>
<ul>
<li>None.</li>
</ul>
<h2><a class="header" href="#reference-11" id="reference-11">Reference</a></h2>
<ul>
<li>See <a href="user/metrics/../../../javadoc/glean/mozilla.telemetry.glean.private/-event-metric-type/index.html">Kotlin API docs</a>.</li>
</ul>
<h1><a class="header" href="#glean-pings" id="glean-pings">Glean Pings</a></h1>
<p>Every Glean ping is in JSON format and contains one or more of the <a href="user/pings/#ping-sections">common sections</a> with shared information data.</p>
<p>If data collection is enabled, the Glean SDK provides a set of built-in pings that are assembled out of the box without any developer intervention.  The following is a list of these built-in pings:</p>
<ul>
<li><a href="user/pings/baseline.html"><code>baseline</code> ping</a></li>
<li><a href="user/pings/events.html"><code>events</code> ping</a></li>
<li><a href="user/pings/metrics.html"><code>metrics</code> ping</a></li>
</ul>
<p>Applications can also define and send their own <a href="user/pings/custom.html">custom pings</a>.</p>
<h2><a class="header" href="#ping-sections" id="ping-sections">Ping sections</a></h2>
<p>There are two standard metadata sections that are added to most pings, in addition to their core metrics and events content (which are described elsewhere in <a href="user/pings/../adding-new-metrics.html">adding new metrics</a>.</p>
<ul>
<li>
<p>The <a href="user/pings/#The-ping_info-section"><code>ping_info</code> section</a> contains core metadata that is included in <strong>every</strong> ping.</p>
</li>
<li>
<p>The <a href="user/pings/#The-client_info-section"><code>client_info</code> section</a> contains information that identifies the client. 
It is included in most pings (including all built-in pings), but may be excluded from pings where we don't want to connect client information with the other metrics in the ping.</p>
</li>
</ul>
<h3><a class="header" href="#the-ping_info-section" id="the-ping_info-section">The <code>ping_info</code> section</a></h3>
<p>The following fields are included in the <code>ping_info</code> section, for every ping. 
Optional fields are marked accordingly.</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ping_type</code></td><td>String</td><td>The name of the ping type (e.g. &quot;baseline&quot;, &quot;metrics&quot;)</td></tr>
<tr><td><code>seq</code></td><td>Counter</td><td>A running counter of the number of times pings of this type have been sent</td></tr>
<tr><td><code>experiments</code></td><td>Object</td><td><em>Optional</em>. A dictionary of <a href="user/pings/#the-experiments-object">active experiments</a></td></tr>
<tr><td><code>start_time</code></td><td>Datetime</td><td>The time of the start of collection of the data in the ping, in local time and with minute precision, including timezone information.</td></tr>
<tr><td><code>end_time</code></td><td>Datetime</td><td>The time of the end of collection of the data in the ping, in local time and with minute precision, including timezone information. This is also the time this ping was generated and is likely well before ping transmission time.</td></tr>
</tbody></table>
<p>All the metrics surviving application restarts (e.g. <code>seq</code>, ...) are removed once the application using the Glean SDK is uninstalled.</p>
<h3><a class="header" href="#the-client_info-section" id="the-client_info-section">The <code>client_info</code> section</a></h3>
<p>The following fields are included in the <code>client_info</code> section.
Optional fields are marked accordingly.</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>app_build</code></td><td>String</td><td>The build identifier generated by the CI system (e.g. &quot;1234/A&quot;)</td></tr>
<tr><td><code>app_display_version</code></td><td>String</td><td>The user-visible version string (e.g. &quot;1.0.3&quot;)</td></tr>
<tr><td><code>app_channel</code></td><td>String</td><td><em>Optional</em> The product-provided release channel (e.g. &quot;beta&quot;)</td></tr>
<tr><td><code>architecture</code></td><td>String</td><td>The architecture of the device (e.g. &quot;arm&quot;, &quot;x86&quot;)</td></tr>
<tr><td><code>client_id</code></td><td>UUID</td><td>A UUID identifying a profile and allowing user-oriented correlation of data</td></tr>
<tr><td><code>device_manufacturer</code></td><td>String</td><td>The manufacturer of the device</td></tr>
<tr><td><code>device_model</code></td><td>String</td><td>The model name of the device</td></tr>
<tr><td><code>first_run_date</code></td><td>Datetime</td><td>The date of the first run of the application, in local time and with day precision, including timezone information.</td></tr>
<tr><td><code>os</code></td><td>String</td><td>The name of the operating system (e.g. &quot;linux&quot;, &quot;Android&quot;, &quot;ios&quot;)</td></tr>
<tr><td><code>os_version</code></td><td>String</td><td>The user visible version of the operating system (e.g. &quot;1.2.3&quot;)</td></tr>
<tr><td><code>android_sdk_version</code></td><td>String</td><td><em>Optional</em>. The Android specific SDK version of the software running on this hardware device (e.g. &quot;23&quot;)</td></tr>
<tr><td><code>telemetry_sdk_build</code></td><td>String</td><td>The version of the Glean SDK</td></tr>
</tbody></table>
<p>All the metrics surviving application restarts (e.g. <code>client_id</code>, ...) are removed once the application using the Glean SDK is uninstalled.</p>
<h3><a class="header" href="#the-experiments-object" id="the-experiments-object">The <code>experiments</code> object</a></h3>
<p>This object (included in the <a href="user/pings/#The-ping_info-section"><code>ping_info</code> section</a>) contains experiments keyed by the experiment <code>id</code>. Each listed experiment contains the <code>branch</code> the client is enrolled in and may contain a string to string map with additional data in the <code>extra</code> key. Both the <code>id</code> and <code>branch</code> are truncated to 30 characters.</p>
<pre><code class="language-json">{
  &quot;&lt;id&gt;&quot;: {
    &quot;branch&quot;: &quot;branch-id&quot;,
    &quot;extra&quot;: {
      &quot;some-key&quot;: &quot;a-value&quot;
    }
  }
}
</code></pre>
<h2><a class="header" href="#ping-submission" id="ping-submission">Ping submission</a></h2>
<p>The pings that the Glean SDK generates are submitted to the Mozilla servers at specific paths, in order to provide additional metadata without the need to unpack the ping payload. 
A typical submission URL looks like</p>
<p><code>&quot;&lt;server-address&gt;/submit/&lt;application-id&gt;/&lt;doc-type&gt;/&lt;glean-schema-version&gt;/&lt;ping-uuid&gt;&quot;</code></p>
<p>where:</p>
<ul>
<li><code>&lt;server-address&gt;</code>: the address of the server that receives the pings;</li>
<li><code>&lt;application-id&gt;</code>: a unique application id, automatically detected by the Glean SDK; this is the value returned by <a href="http://developer.android.com/reference/android/content/Context.html#getPackageName()"><code>Context.getPackageName()</code></a>;</li>
<li><code>&lt;doc-type&gt;</code>: the name of the ping; this can be one of the pings available out of the box with the Glean SDK, or a custom ping;</li>
<li><code>&lt;glean-schema-version&gt;</code>: the version of the Glean ping schema;</li>
<li><code>&lt;ping-uuid&gt;</code>: a unique identifier for this ping.</li>
</ul>
<h3><a class="header" href="#submitted-headers" id="submitted-headers">Submitted headers</a></h3>
<p>A pre-defined set of headers is additionally sent along with the submitted ping:</p>
<table><thead><tr><th>Header</th><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Content-Type</code></td><td><code>application/json; charset=utf-8</code></td><td>Describes the data sent to the server</td></tr>
<tr><td><code>User-Agent</code></td><td>Defaults to e.g. <code>Glean/0.40.0 (Android)</code>, where <code>0.40.0</code> is the Glean SDK version number and <code>Android</code> is the platform name. It can be overriden by user through <a href="user/pings/../../../javadoc/glean/mozilla.telemetry.glean/-configuration/index.html">configuration</a></td><td>Describes the application sending the ping using the Glean SDK</td></tr>
<tr><td><code>Date</code></td><td>e.g. <code>Mon, 23 Jan 2019 10:10:10 GMT+00:00</code></td><td>Submission date/time in GMT/UTC+0 offset</td></tr>
<tr><td><code>X-Client-Type</code></td><td><code>Glean</code></td><td>Custom header to support handling of Glean pings in the legacy pipeline</td></tr>
<tr><td><code>X-Client-Version</code></td><td>e.g. <code>0.40.0</code></td><td>The Glean SDK version, sent as a custom header to support handling of Glean pings in the legacy pipeline</td></tr>
</tbody></table>
<h2><a class="header" href="#defining-background-state" id="defining-background-state">Defining background state</a></h2>
<p>These docs refer to application 'background' state in several places. 
This specifically means when the activity is no longer visible to the user, it has entered the Stopped state, and the system invokes the <a href="https://developer.android.com/reference/android/app/Activity.html#onStop()"><code>onStop()</code></a> callback.
This may occur, for example, when a newly launched activity covers the entire screen. 
The system may also call <code>onStop()</code> when the activity has finished running, and is about to be terminated.</p>
<h1><a class="header" href="#the-baseline-ping" id="the-baseline-ping">The <code>baseline</code> ping</a></h1>
<h2><a class="header" href="#description" id="description">Description</a></h2>
<p>This ping is intended to provide metrics that are managed by the library itself, and not explicitly set by the application or included in the application's <code>metrics.yaml</code> file.
If the application crashes no <code>baseline</code> ping is sent, no additional ping is generated with the data from before the crash.</p>
<h2><a class="header" href="#scheduling" id="scheduling">Scheduling</a></h2>
<p>The <code>baseline</code> ping is automatically sent when the application is moved to the <a href="user/pings/index.html#defining-background-state">background</a>.</p>
<h2><a class="header" href="#contents" id="contents">Contents</a></h2>
<p>The baseline ping includes the following fields:</p>
<table><thead><tr><th>Field name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>duration</code></td><td>Timespan</td><td>The duration, in seconds, of the last foreground session</td></tr>
<tr><td><code>locale</code></td><td>String</td><td>The locale of the application</td></tr>
</tbody></table>
<p>The <code>baseline</code> ping shall also include the common <a href="user/pings/index.html#ping-sections">ping sections</a> found in all pings.</p>
<h3><a class="header" href="#querying-ping-contents" id="querying-ping-contents">Querying ping contents</a></h3>
<p>A quick note about querying ping contents (i.e. for https://sql.telemetry.mozilla.org):  Each metric in the baseline ping is organized by its metric type, and uses a namespace of <code>glean.baseline</code>. For instance, in order to select <code>duration</code> you would use <code>metrics.timespan['glean.baseline.duration']</code>. If you were trying to select a String based metric such as <code>os</code>, then you would use <code>metrics.string['glean.baseline.os']</code></p>
<h2><a class="header" href="#example-baseline-ping" id="example-baseline-ping">Example baseline ping</a></h2>
<pre><code class="language-json">{
  &quot;ping_info&quot;: {
    &quot;ping_type&quot;: &quot;baseline&quot;,
    &quot;experiments&quot;: {
      &quot;third_party_library&quot;: {
        &quot;branch&quot;: &quot;enabled&quot;
      }
    },
    &quot;seq&quot;: 0,
    &quot;start_time&quot;: &quot;2019-03-29T09:50-04:00&quot;,
    &quot;end_time&quot;: &quot;2019-03-29T09:53-04:00&quot;
  },
  &quot;client_info&quot;: {
    &quot;telemetry_sdk_build&quot;: &quot;0.49.0&quot;,
    &quot;first_run_date&quot;: &quot;2019-03-29-04:00&quot;,
    &quot;os&quot;: &quot;Android&quot;,
    &quot;android_sdk_version&quot;: &quot;27&quot;,
    &quot;os_version&quot;: &quot;8.1.0&quot;,
    &quot;device_manufacturer&quot;: &quot;Google&quot;,
    &quot;device_model&quot;: &quot;Android SDK built for x86&quot;,
    &quot;architecture&quot;: &quot;x86&quot;,
    &quot;app_build&quot;: &quot;1&quot;,
    &quot;app_display_version&quot;: &quot;1.0&quot;,
    &quot;client_id&quot;: &quot;35dab852-74db-43f4-8aa0-88884211e545&quot;
  },
  &quot;metrics&quot;: {
    &quot;string&quot;: {
      &quot;glean.baseline.locale&quot;: &quot;en-US&quot;
    },
    &quot;timespan&quot;: {
      &quot;glean.baseline.duration&quot;: {
        &quot;value&quot;: 52,
        &quot;time_unit&quot;: &quot;second&quot;
      }
    }
  }
}
</code></pre>
<h1><a class="header" href="#the-metrics-ping" id="the-metrics-ping">The <code>metrics</code> ping</a></h1>
<h2><a class="header" href="#description-1" id="description-1">Description</a></h2>
<p>The <code>metrics</code> ping is intended for all of the metrics that are explicitly set by the application or are included in the application's <code>metrics.yaml</code> file (except events). 
The reported data is tied to the ping's <em>measurement window</em>, which is the time between the collection of two <code>metrics</code> ping. 
Ideally, this window is expected to be about 24 hours, given that the collection is scheduled daily at 4AM. 
Data in the <a href="user/pings/index.html#the-ping_info-section"><code>ping_info</code></a> section of the ping can be used to infer the length of this window.
If the application crashes, unsent recorded metrics are sent along with the next <code>metrics</code> ping.</p>
<h2><a class="header" href="#scheduling-1" id="scheduling-1">Scheduling</a></h2>
<p>The desired behaviour is to collect the ping at the first available opportunity after 4AM local time on a new calendar day. 
This breaks down into three scenarios:</p>
<ol>
<li>the application was just installed;</li>
<li>the application was just started (after a crash or a long inactivity period);</li>
<li>the application was open and the 4AM due time was hit.</li>
</ol>
<p>In the first case, since the application was just installed, if the due time for the current calendar day has passed, a <code>metrics</code> ping is immediately generated and scheduled for sending. Otherwise, if the due time for the current calendar day has not passed, a ping collection is scheduled for that time.</p>
<p>In the second case, if the <code>metrics</code> ping was already collected on the current calendar day, a new collection will be scheduled for the next calendar day, at 4AM. 
If no collection happened yet, and the due time for the current calendar day has passed, a <code>metrics</code> ping is immediately generated and scheduled for sending.</p>
<p>In the third case, similarly to the previous case, if the <code>metrics</code> ping was already collected on the current calendar day when we hit 4AM, then a new collection is scheduled for the next calendar day.
Otherwise, the <code>metrics</code> is immediately collected and scheduled for sending.</p>
<p>More <a href="user/pings/#Scheduling-examples">scheduling examples</a> are included below.</p>
<h2><a class="header" href="#contents-1" id="contents-1">Contents</a></h2>
<p>The <code>metrics</code> ping contains all of the metrics defined in <code>metrics.yaml</code> (except events) that don't specify a ping or where <code>default</code> is specified in their <a href="https://mozilla.github.io/glean_parser/metrics-yaml.html#send-in-pings"><code>send in pings</code></a> property.</p>
<p>Additionally, error metrics in the <code>glean.error</code> category are included in the <code>metrics</code> ping.</p>
<p>The <code>metrics</code> ping shall also include the common <a href="user/pings/index.html#the-ping_info-section"><code>ping_info</code></a> and <a href="user/pings/index.html#the-client_info-section">'client_info'</a> sections.</p>
<h3><a class="header" href="#querying-ping-contents-1" id="querying-ping-contents-1">Querying ping contents</a></h3>
<p>A quick note about querying ping contents (i.e. for <a href="https://sql.telemetry.mozilla.org">sql.telemetry.mozilla.org</a>):  Each metric in the metrics ping is organized by its metric type, and uses a namespace of 'glean.metrics'. 
For instance, in order to select a String field called <code>test</code> you would use <code>metrics.string['glean.metrics.test']</code>.</p>
<h3><a class="header" href="#example-metrics-ping" id="example-metrics-ping">Example metrics ping</a></h3>
<pre><code class="language-json">{
  &quot;ping_info&quot;: {
    &quot;ping_type&quot;: &quot;metrics&quot;,
    &quot;experiments&quot;: {
      &quot;third_party_library&quot;: {
        &quot;branch&quot;: &quot;enabled&quot;
      }
    },
    &quot;seq&quot;: 0,
    &quot;start_time&quot;: &quot;2019-03-29T09:50-04:00&quot;,
    &quot;end_time&quot;: &quot;2019-03-29T10:02-04:00&quot;
  },
  &quot;client_info&quot;: {
    &quot;telemetry_sdk_build&quot;: &quot;0.49.0&quot;,
    &quot;first_run_date&quot;: &quot;2019-03-29-04:00&quot;,
    &quot;os&quot;: &quot;Android&quot;,
    &quot;android_sdk_version&quot;: &quot;27&quot;,
    &quot;os_version&quot;: &quot;8.1.0&quot;,
    &quot;device_manufacturer&quot;: &quot;Google&quot;,
    &quot;device_model&quot;: &quot;Android SDK built for x86&quot;,
    &quot;architecture&quot;: &quot;x86&quot;,
    &quot;app_build&quot;: &quot;1&quot;,
    &quot;app_display_version&quot;: &quot;1.0&quot;,
    &quot;client_id&quot;: &quot;35dab852-74db-43f4-8aa0-88884211e545&quot;
  },
  &quot;metrics&quot;: {
    &quot;counter&quot;: {
      &quot;sample_metrics.test&quot;: 1
    },
    &quot;string&quot;: {
      &quot;basic.os&quot;: &quot;Android&quot;
    },
    &quot;timespan&quot;: {
      &quot;test.test_timespan&quot;: {
        &quot;time_unit&quot;: &quot;microsecond&quot;,
        &quot;value&quot;: 181908
      }
    }
  }
}
</code></pre>
<h2><a class="header" href="#scheduling-examples" id="scheduling-examples">Scheduling Examples</a></h2>
<h3><a class="header" href="#crossing-due-time-with-the-application-closed" id="crossing-due-time-with-the-application-closed">Crossing due time with the application closed</a></h3>
<ol>
<li>
<p>The application is opened on Feb 7 on 3PM, closed on 3:05PM.</p>
<ul>
<li>Glean records one metric A (say startup time in ms) during this measurement window MW1.</li>
</ul>
</li>
<li>
<p>The application is opened again on Feb 8 on 5PM.</p>
</li>
</ol>
<ul>
<li>
<p>Glean notes that we passed local 4AM since MW1.</p>
</li>
<li>
<p>Glean closes MW1, with:</p>
<ul>
<li><code>start_time=Feb7/3PM</code>;</li>
<li><code>end_time=Feb8/5PM</code>.</li>
</ul>
</li>
<li>
<p>Glean records metric A again, into MW2, which has a start_time of Feb8/5PM.</p>
</li>
</ul>
<h3><a class="header" href="#crossing-due-time-and-changing-timezones" id="crossing-due-time-and-changing-timezones">Crossing due time and changing timezones</a></h3>
<ol>
<li>
<p>The application is opened on Feb 7 on 3PM in timezone UTC, closed on 3:05PM.</p>
<ul>
<li>Glean records one metric A (say startup time in ms) during this measurement window MW1.</li>
</ul>
</li>
<li>
<p>The application is opened again on Feb 8 on 5PM in timezone UTC+1.</p>
<ul>
<li>
<p>Glean notes that we passed local 4AM UTC+1 since MW1.</p>
</li>
<li>
<p>Glean closes MW1, with:</p>
<ul>
<li><code>start_time=Feb7/3PM/UTC</code>;</li>
<li><code>end_time=Feb8/5PM/UTC+1</code>.</li>
</ul>
</li>
<li>
<p>Glean records metric A again, into MW2.</p>
</li>
</ul>
</li>
</ol>
<h3><a class="header" href="#the-application-doesnt-run-in-a-week" id="the-application-doesnt-run-in-a-week">The application doesn’t run in a week</a></h3>
<ol>
<li>
<p>The application is opened on Feb 7 on 3PM in timezone UTC, closed on 3:05PM.</p>
<ul>
<li>Glean records one metric A (say startup time in ms) during this measurement window MW1.</li>
</ul>
</li>
<li>
<p>The application is opened again on Feb 16 on 5PM in timezone UTC.</p>
<ul>
<li>
<p>Glean notes that we passed local 4AM UTC since MW1.</p>
</li>
<li>
<p>Glean closes MW1, with:</p>
<ul>
<li><code>start_time=Feb7/3PM/UTC</code>;</li>
<li><code>end_time=Feb16/5PM/UTC</code>.</li>
</ul>
</li>
<li>
<p>Glean records metric A again, into MW2.</p>
</li>
</ul>
</li>
</ol>
<h3><a class="header" href="#the-application-doesnt-run-for-a-week-and-when-its-finally-re-opened-the-timezone-has-changed" id="the-application-doesnt-run-for-a-week-and-when-its-finally-re-opened-the-timezone-has-changed">The application doesn’t run for a week, and when it’s finally re-opened the timezone has changed</a></h3>
<ol>
<li>
<p>The application is opened on Feb 7 on 3PM in timezone UTC, closed on 3:05PM.</p>
<ul>
<li>Glean records one metric A (say startup time in ms) during this measurement window MW1.</li>
</ul>
</li>
<li>
<p>The application is opened again on Feb 16 on 5PM in timezone UTC+1.</p>
<ul>
<li>
<p>Glean notes that we passed local 4AM UTC+1 since MW1.</p>
</li>
<li>
<p>Glean closes MW1, with:</p>
<ul>
<li><code>start_time=Feb7/3PM/UTC</code></li>
<li><code>end_time=Feb16/5PM/UTC+1</code>.</li>
</ul>
</li>
<li>
<p>Glean records metric A again, into MW2.</p>
</li>
</ul>
</li>
</ol>
<h3><a class="header" href="#the-user-changes-timezone-in-an-extreme-enough-fashion-that-they-cross-4am-twice-on-the-same-date" id="the-user-changes-timezone-in-an-extreme-enough-fashion-that-they-cross-4am-twice-on-the-same-date">The user changes timezone in an extreme enough fashion that they cross 4AM twice on the same date</a></h3>
<ol>
<li>
<p>The application is opened on Feb 7 at 3PM in timezone UTC+11, closed at 3:05PM</p>
<ul>
<li>Glean records one metric A (say startup time in ms) during this measurement window MW1.</li>
</ul>
</li>
<li>
<p>The application is opened again on Feb 8 at 4:30AM in timezone UTC+11.</p>
<ul>
<li>
<p>Glean notes that we passed local 4AM UTC+11.</p>
</li>
<li>
<p>Glean closes MW1, with:</p>
<ul>
<li><code>start_time=Feb7/3PM/UTC+11</code>;</li>
<li><code>end_time=Feb8/4:30AM/UTC+11</code>.</li>
</ul>
</li>
<li>
<p>Glean records metric A again, into MW2.</p>
</li>
</ul>
</li>
<li>
<p>The user changes to timezone UTC-10 and opens the application at Feb 7 at 10PM in timezone UTC-10</p>
<ul>
<li>Glean records metric A again, into MW2 (not MW1, which was already sent).</li>
</ul>
</li>
<li>
<p>The user opens the application at Feb 8 5AM in timezone UTC-10</p>
<ul>
<li>Glean notes that we have not yet passed local 4AM on Feb 9</li>
<li>Measurement window MW2 remains the current measurement window</li>
</ul>
</li>
<li>
<p>The user opens the application at Feb 9 7AM in timezone UTC-10</p>
<ul>
<li>
<p>Glean notes that we have passed local 4AM on Feb 9</p>
</li>
<li>
<p>Glean closes MW2 with:</p>
<ul>
<li><code>start_time=Feb8/4:30AM/UTC+11</code>;</li>
<li><code>end_time=Feb9/7AM/UTC-10</code>.</li>
</ul>
</li>
<li>
<p>Glean records metric A again, into MW3.</p>
</li>
</ul>
</li>
</ol>
<h1><a class="header" href="#the-events-ping" id="the-events-ping">The <code>events</code> ping</a></h1>
<h2><a class="header" href="#description-2" id="description-2">Description</a></h2>
<p>The events ping's purpose is to transport all of the event metric information.
If the application crashes, an <code>events</code> ping is generated next time the application starts with events that were not sent before the crash.</p>
<h2><a class="header" href="#scheduling-2" id="scheduling-2">Scheduling</a></h2>
<p>The <code>events</code> ping is sent under the following circumstances:</p>
<ul>
<li>
<p>Normally, it is sent when the application goes into the <a href="user/pings/index.html#defining-background-state">background</a>, if there are any recorded events to send.</p>
</li>
<li>
<p>When the queue of events exceeds <code>Glean.configuration.maxEvents</code> (default 500).</p>
</li>
<li>
<p>If there are any unsent events found on disk when starting the application. It would be impossible to coordinate the timestamps across a reboot, so it's best to just collect all events from the previous run into their own ping, and start over.</p>
</li>
</ul>
<p>All of these cases are handled automatically, with no intervention or configuration required by the application.</p>
<h2><a class="header" href="#contents-2" id="contents-2">Contents</a></h2>
<p>At the top-level, this ping contains the following keys:</p>
<ul>
<li>
<p><code>ping_info</code>: The information <a href="user/pings/index.html#the-ping_info-section">common to all pings</a>.</p>
</li>
<li>
<p><code>events</code>: An array of all of the events that have occurred since the last time the <code>events</code> ping was sent.</p>
</li>
</ul>
<p>Each entry in the <code>events</code> array is an object with the following properties:</p>
<ul>
<li>
<p><code>&quot;timestamp&quot;</code>: The milliseconds relative to the first event in the ping.</p>
</li>
<li>
<p><code>&quot;category&quot;</code>: The category of the event, as defined by its location in the <code>metrics.yaml</code> file.</p>
</li>
<li>
<p><code>&quot;name&quot;</code>: The name of the event, as definded in the <code>metrics.yaml</code> file.</p>
</li>
<li>
<p><code>&quot;extra&quot;</code> (optional): A mapping of strings to strings providing additional data about the event. The keys are restricted to 40 characters and values in this map will never exceed 100 characters.</p>
</li>
</ul>
<h3><a class="header" href="#example-event-json" id="example-event-json">Example event JSON</a></h3>
<pre><code class="language-json">{
  &quot;ping_info&quot;: {
    &quot;ping_type&quot;: &quot;metrics&quot;,
    &quot;experiments&quot;: {
      &quot;third_party_library&quot;: {
        &quot;branch&quot;: &quot;enabled&quot;
      }
    },
    &quot;seq&quot;: 0,
    &quot;start_time&quot;: &quot;2019-03-29T09:50-04:00&quot;,
    &quot;end_time&quot;: &quot;2019-03-29T10:02-04:00&quot;
  },
  &quot;client_info&quot;: {
    &quot;telemetry_sdk_build&quot;: &quot;0.49.0&quot;,
    &quot;first_run_date&quot;: &quot;2019-03-29-04:00&quot;,
    &quot;os&quot;: &quot;Android&quot;,
    &quot;android_sdk_version&quot;: &quot;27&quot;,
    &quot;os_version&quot;: &quot;8.1.0&quot;,
    &quot;device_manufacturer&quot;: &quot;Google&quot;,
    &quot;device_model&quot;: &quot;Android SDK built for x86&quot;,
    &quot;architecture&quot;: &quot;x86&quot;,
    &quot;app_build&quot;: &quot;1&quot;,
    &quot;app_display_version&quot;: &quot;1.0&quot;,
    &quot;client_id&quot;: &quot;35dab852-74db-43f4-8aa0-88884211e545&quot;
  },
  &quot;events&quot;: [
    {
      &quot;timestamp&quot;: 123456789,
      &quot;category&quot;: &quot;examples&quot;,
      &quot;name&quot;: &quot;event_example&quot;,
      &quot;extra&quot;: {
        &quot;metadata1&quot;: &quot;extra&quot;, 
        &quot;metadata2&quot;: &quot;more_extra&quot;
      }
    },
    {
      &quot;timestamp&quot;: 123456791,
      &quot;category&quot;: &quot;examples&quot;,
      &quot;name&quot;: &quot;event_example&quot;
    }
  ]
}
</code></pre>
<h1><a class="header" href="#custom-pings" id="custom-pings">Custom pings</a></h1>
<p>Applications can define metrics that are sent in custom pings. Unlike the built-in pings, custom pings are sent explicitly by the application.</p>
<h2><a class="header" href="#defining-a-custom-ping" id="defining-a-custom-ping">Defining a custom ping</a></h2>
<p>Custom pings must be defined in a <code>pings.yaml</code> file, which is in the same directory alongside your app's <code>metrics.yaml</code> file.</p>
<p>Each ping has the following parameters:</p>
<ul>
<li><code>include_client_id</code> (required): A boolean indicating whether to include the
<code>client_id</code> in the <a href="user/pings/index.html#The-client_info-section"><code>client_info</code> section</a>).</li>
</ul>
<p>In addition to these parameters, pings also support the parameters related to data review and expiration defined in <a href="user/pings/../adding-new-metrics.html#common-metric-parameters">common metric parameters</a>: <code>description</code>, <code>notification_emails</code>, <code>bugs</code>, and <code>data_reviews</code>.</p>
<p>For example, to define a custom ping called <code>search</code> specifically for search information:</p>
<pre><code class="language-YAML"># Required to indicate this is a `pings.yaml` file
$schema: moz://mozilla.org/schemas/glean/pings/1-0-0

search:
  description: &gt;
    A ping to record search data.
  include_client_id: false
  notification_emails:
    - CHANGE-ME@example.com
  bugs:
    - 123456789
  data_reviews:
    - http://example.com/path/to/data-review
</code></pre>
<h2><a class="header" href="#loading-custom-ping-metadata-into-your-application-or-library" id="loading-custom-ping-metadata-into-your-application-or-library">Loading custom ping metadata into your application or library</a></h2>
<p>The Glean SDK build generates code from <code>pings.yaml</code> in a <code>Pings</code> object, which must be instantiated so Glean can send pings by name. 
This object must be registered with Glean from your startup code (such as in your application's <code>onCreate</code> method or a function called from that method).</p>
<pre><code>import org.mozilla.yourApplication.GleanMetrics.Pings

...

override fun onCreate() {
    ...
    Glean.registerPings(Pings)
    ...
}
</code></pre>
<h2><a class="header" href="#sending-metrics-in-a-custom-ping" id="sending-metrics-in-a-custom-ping">Sending metrics in a custom ping</a></h2>
<p>To send a metric on a custom ping, you add the custom ping's name to the <code>send_in_pings</code> parameter in the <code>metrics.yaml</code> file.</p>
<p>For example, to define a new metric to record the default search engine, which is sent in a custom ping called <code>search</code>, put <code>search</code> in the <code>send_in_pings</code> parameter.  Note that it is an error to specify a ping in <code>send_in_pings</code> that does not also have an entry in <code>pings.yaml</code>.</p>
<pre><code class="language-YAML">search.default:
  name:
    type: string
    description: &gt;
      The name of the default search engine.
    send_in_pings:
      - search
</code></pre>
<p>If this metric should also be sent in the default ping for the given metric type, you can add the special value <code>default</code> to <code>send_in_pings</code>:</p>
<pre><code class="language-YAML">    send_in_pings:
      - search
      - default
</code></pre>
<h2><a class="header" href="#sending-a-custom-ping" id="sending-a-custom-ping">Sending a custom ping</a></h2>
<p>To send a custom ping, call the <code>send</code> method on the <code>PingType</code> object that the Glean SDK generated for your ping.</p>
<p>For example, to send the custom ping defined above:</p>
<pre><code class="language-kotlin">import org.mozilla.yourApplication.GleanMetrics.Pings
Pings.search.send()
</code></pre>
<h1><a class="header" href="#unit-testing-glean-custom-pings" id="unit-testing-glean-custom-pings">Unit testing Glean custom pings</a></h1>
<p>Applications defining <a href="user/pings/custom.html">custom pings</a> can use use the strategy defined in this document to test these pings in unit tests.</p>
<h2><a class="header" href="#general-testing-strategy" id="general-testing-strategy">General testing strategy</a></h2>
<p>The schedule of custom pings depends on the specific application implementation, since it is up to the SDK user to define the ping semantics. This makes writing unit tests for custom pings a bit more involved.</p>
<p>One possible strategy could be to wrap the Glean SDK API call to send the ping in a function that can be mocked in the unit test. This would allow for checking the status and the values of the metrics contained in the ping at the time in which the application would have sent it.</p>
<h2><a class="header" href="#example-testing-of-a-custom-ping" id="example-testing-of-a-custom-ping">Example testing of a custom ping</a></h2>
<p>Let us start by defining a custom ping with a sample metric in it. Here is the <code>pings.yaml</code> file:</p>
<pre><code class="language-yaml">$schema: moz://mozilla.org/schemas/glean/pings/1-0-0

my_custom_ping:
  description: &gt;
    This ping is intended to showcase the recommended testing strategy for
    custom pings.
  include_client_id: false
  bugs:
    - 1556985
  data_reviews:
    - https://bugzilla.mozilla.org/show_bug.cgi?id=1556985
  notification_emails:
    - custom-ping-owner@example.com

</code></pre>
<p>And here is the <code>metrics.yaml</code></p>
<pre><code class="language-yaml">$schema: moz://mozilla.org/schemas/glean/metrics/1-0-0

custom_ping_data:
  sample_string:
    type: string
    lifetime: ping
    description: &gt;
      A sample string metric for demonstrating unit tests for custom pings.
    send_in_pings:
      - my_custom_ping
    bugs:
      - 1556985
    data_reviews:
      - https://bugzilla.mozilla.org/show_bug.cgi?id=1556985
    notification_emails:
      - custom-ping-owner@example.com
    expires: &quot;2019-10-01&quot;
</code></pre>
<p>A potential usage of the Glean SDK generated API could be the following:</p>
<pre><code class="language-kotlin">import my.component.GleanMetrics.Pings
import my.component.GleanMetrics.CustomPingData

class MyCustomPingScheduler {
  /**
   * HERE ONLY TO KEEP THE EXAMPLE SIMPLE.
   *
   * A function that consumes the Glean SDK generated metrics API to
   * record some data. It doesn't really need to be in a function, nor
   * in this class. The Glean SDK API can be called when the data is
   * generated.
   */
  fun addSomeData() {
    // Record some sample data.
    CustomPingData.sampleString.set(&quot;test-data&quot;)
  }

  /**
   * Called to implement the ping scheduling logic for 'my_custom_ping'.
   */
  fun schedulePing() {
    // ... some scheduling logic that will end up calling the function below.
    sendPing()
  }

  /**
   * Internal function to only be overriden in tests. This
   * calls the Glean SDK API to send custom pings.
   */
  @VisibleForTesting(otherwise = VisibleForTesting.NONE)
  internal fun sendPing() {
    Pings.MyCustomPing.send()
  }
}
</code></pre>
<p>Finally, here is a simple unit test that intercepts the <code>MyCustomPingScheduler.schedulePing()</code> call in order to perform the validation on the data. This specific example uses Mockito, but any other framework would work.</p>
<pre><code class="language-kotlin">// Metrics and pings definitions.
import my.component.GleanMetrics.Pings
import my.component.GleanMetrics.CustomPingData

// Mockito imports for using spies.
import org.mockito.Mockito.spy
import org.mockito.Mockito.`when`

/**
 * This is an helper function used to enable testing mode for Glean.
 * Should only be called once before the tests, but nothing breaks if it's
 * called more than once!
 */
fun setupGleanOnce() {
  // Enable testing mode
  // (Perhaps called from a @Before method so it precedes every test in the suite.)
  Glean.enableTestingMode()

  // We're using the WorkManager in a bunch of places, and Glean will crash
  // in tests without this line. Let's simply put it here.
  WorkManagerTestInitHelper.initializeTestWorkManager(context)

  Glean.initialize(context)
}

@Test
fun `verify custom ping metrics`() {
  setupGleanOnce()

  val scheduler = spy(MyCustomPingScheduler())
  doAnswer {
    // Here we validate the content that goes into the ping.
    assertTrue(CustomPingData.sampleString.testHasValue())
    assertEquals(&quot;test-data&quot;, CustomPingData.sampleString.testGetValue())

    // We want to intercept this call, but we also want to make sure the
    // real Glean API is called in order to clear the ping store and to provide
    // consistent behaviour with respect to the application.
    it.callRealMethod()
  }.`when`(scheduler).sendPing()

  scheduler.addSomeData()
  scheduler.schedulePing()
}
</code></pre>
<h1><a class="header" href="#developing-the-glean-sdk" id="developing-the-glean-sdk">Developing the Glean SDK</a></h1>
<p>In this chapter we describe how to develop the Glean SDK.</p>
<blockquote>
<p><strong>Note:</strong> This chapter describes how to develop the cross-platform implementation of the Glean SDK. For information about developing the Android-specific implementation, see <a href="https://github.com/mozilla-mobile/android-components">android-components</a>.</p>
</blockquote>
<h1><a class="header" href="#running-the-tests" id="running-the-tests">Running the tests</a></h1>
<blockquote>
<p><strong>Note:</strong> This document describes testing the cross-platform implementation of the Glean SDK. For information about testing Android-specific implementation, see <a href="https://github.com/mozilla-mobile/android-components">android-components</a>.</p>
</blockquote>
<h2><a class="header" href="#running-all-tests" id="running-all-tests">Running all tests</a></h2>
<p>The tests for all languages may be run from the command line:</p>
<pre><code>make test
</code></pre>
<blockquote>
<p><strong>Windows Note:</strong> On Windows, <code>make</code> is not available by default. While not required, installing <code>make</code> will allow you to use the convenience features in the <code>Makefile</code>.</p>
</blockquote>
<h2><a class="header" href="#running-the-rust-tests" id="running-the-rust-tests">Running the Rust tests</a></h2>
<p>The Rust tests may be run with the following command:</p>
<pre><code>cargo test --all
</code></pre>
<p>Log output can be controlled via the environment variable <code>RUST_LOG</code> for the <code>glean_core</code> crate:</p>
<pre><code>export RUST_LOG=glean_core=debug
</code></pre>
<p>When running tests with logging you need to tell <code>cargo</code> to not suppress output:</p>
<pre><code>cargo test -- --nocapture
</code></pre>
<p>Tests run in parallel by default, leading to interleaving log lines.
This makes it harder to understand what's going on.
For debugging you can force single-threaded tests:</p>
<pre><code>cargo test -- --nocapture --test-threads=1
</code></pre>
<h2><a class="header" href="#running-the-kotlinandroid-tests" id="running-the-kotlinandroid-tests">Running the Kotlin/Android tests</a></h2>
<h3><a class="header" href="#from-the-command-line" id="from-the-command-line">From the command line</a></h3>
<p>The full Android test suite may be run from the command line with:</p>
<pre><code>./gradlew test
</code></pre>
<h3><a class="header" href="#from-android-studio" id="from-android-studio">From Android Studio</a></h3>
<p>To run the full Android test suite, in the &quot;Gradle&quot; pane, navigate to <code>glean-core</code> -&gt; <code>Tasks</code> -&gt; <code>verification</code> and double-click either <code>testDebugUnitTest</code> or <code>testReleaseUnitTest</code> (depending on whether you want to run in Debug or Release mode).
You can save this task permanently by opening the task dropdown in the toolbar and selecting &quot;Save glean.rs:glean-core:android [testDebugUnitTest] Configuration&quot;.</p>
<p>To run a single Android test, navigate to the file containing the test, and right click on the green arrow in the left margin next to the test.  There you have a choice of running or debugging the test.</p>
<h2><a class="header" href="#testing-in-ci" id="testing-in-ci">Testing in CI</a></h2>
<p>We run multiple tests on CI for every Pull Request and every commit to the <code>master</code> branch.
These include:</p>
<ul>
<li>Full Android tests</li>
<li>Rust tests</li>
<li>Rust source code formatting</li>
<li>Rust and Android source code linting</li>
<li>Generating documentation from Rust &amp; Kotlin code and the book</li>
<li>Checking link validity of documentation</li>
<li>Deploying generated documentation</li>
</ul>
<p>These checks are required to pass before a Pull Request is merged.</p>
<h3><a class="header" href="#documentation-only-changes" id="documentation-only-changes">Documentation-only changes</a></h3>
<p>Documentation is deployed from CI, we therefore need it to run on documentation changes.
However, some of the long-running code tests can be skipped.
For that add the following literal string to the last commit message to be pushed:</p>
<pre><code>[doc only]
</code></pre>
<h3><a class="header" href="#skipping-ci-completely" id="skipping-ci-completely">Skipping CI completely</a></h3>
<p>It is possible to completely skip running CI on a given push by including the following literal string in the commit message:</p>
<pre><code>[ci skip]
</code></pre>
<p>This should only be used for metadata files, such as those in <code>.github</code>, <code>LICENSE</code> or <code>CODE_OF_CONDUCT.md</code>.</p>
<h1><a class="header" href="#android-bindings" id="android-bindings">Android bindings</a></h1>
<p>The Glean SDK contains the Kotlin bindings for use by Android applications.
It makes use of the underlying <a href="dev/android/../core/index.html">Rust component</a> with a Kotlin-specific API on top.
It also includes integrations into the Android platform.</p>
<h1><a class="header" href="#setup-the-android-build-environment" id="setup-the-android-build-environment">Setup the Android Build Environment</a></h1>
<blockquote>
<p><strong>Important:</strong> This documentation refers to setting up the development environment for the <a href="https://github.com/mozilla/glean">cross-platform implementation of the Glean SDK</a>.  Instructions for setting up the implementation in android-components is documented in the <a href="https://github.com/mozilla-mobile/android-components">android-components repository</a>.</p>
</blockquote>
<h2><a class="header" href="#doing-a-local-build-of-the-android-components" id="doing-a-local-build-of-the-android-components">Doing a local build of the Android Components:</a></h2>
<p>This document describes how to make local builds of the Android bindings in
this repository. Most consumers of these bindings <em>do not</em> need to follow
this process, but will instead use pre-built bindings [todo: link to this]</p>
<h2><a class="header" href="#prepare-your-build-environment" id="prepare-your-build-environment">Prepare your build environment</a></h2>
<p>Typically, this process only needs to be run once, although periodically you
may need to repeat some steps (eg, rust updates should be done periodically)</p>
<h3><a class="header" href="#setting-up-android-dependencies" id="setting-up-android-dependencies">Setting up Android dependencies</a></h3>
<p>At the end of this process you should have the following environment variables set up.</p>
<ul>
<li><code>ANDROID_HOME</code></li>
<li><code>NDK_HOME</code></li>
<li><code>JAVA_HOME</code></li>
</ul>
<p>The easiest way to install all the dependencies (and automatically
handle updates), is by using <a href="https://developer.android.com/studio/index.html">Android Studio</a>.
Once this is installed, it must be run and the Glean project opened to complete initial setup.
If Android Studio asks you to upgrade the verison of gradle, decline.</p>
<p>The following dependencies can be installed in Android Studio through <code>Tools &gt; SDK Manager &gt; SDK Tools</code>:</p>
<ul>
<li>Android SDK Tools (may already be selected)</li>
<li>NDK</li>
<li>CMake</li>
<li>LLDB</li>
</ul>
<p>With the dependencies installed, note down the <code>Android SDK Location</code> in <code>Tools &gt; SDK Manager</code>.
Set the <code>ANDROID_HOME</code> environment variable to that path.
The <code>NDK_HOME</code> can be set to <code>NDK_HOME=$ANDROID_HOME/ndk-bundle</code>.
Set <code>JAVA_HOME</code> to be the location of Android Studio's JDK which can be found in Glean's &quot;Project Structure&quot; menu. (You may need to escape spaces in the path).</p>
<h3><a class="header" href="#setting-up-rust" id="setting-up-rust">Setting up Rust</a></h3>
<p>Rust can be installed using <code>rustup</code>, with the following commands:</p>
<ul>
<li><code>curl https://sh.rustup.rs -sSf | sh</code></li>
<li><code>rustup update</code></li>
</ul>
<p>Platform specific toolchains need to be installed for Rust. This can be
done using the <code>rustup target</code> command. In order to enable building to real
devices and Android emulators, the following targets need to be installed:</p>
<ul>
<li><code>rustup target add aarch64-linux-android</code></li>
<li><code>rustup target add armv7-linux-androideabi</code></li>
<li><code>rustup target add i686-linux-android</code></li>
<li><code>rustup target add x86_64-linux-android</code></li>
</ul>
<p>The <code>mdbook</code> crate is required in order to build documentation:</p>
<ul>
<li><code>cargo install mdbook</code></li>
</ul>
<h2><a class="header" href="#building" id="building">Building</a></h2>
<p>This should be relatively straightforward and painless:</p>
<ol>
<li>
<p>Ensure your repository is up-to-date.</p>
</li>
<li>
<p>Ensure rust is up-to-date by running <code>rustup</code></p>
</li>
<li>
<p>The builds are all performed by <code>./gradlew</code> and the general syntax used is
<code>./gradlew project:task</code></p>
<p>You can see a list of projects by executing <code>./gradlew projects</code> and a list
of tasks by executing <code>./gradlew tasks</code>.</p>
</li>
</ol>
<p>The above can be skipped if using <code>Android Studio</code>. The project directory can be imported
and all the build details can be left to the IDE.</p>
<h2><a class="header" href="#faq" id="faq">FAQ</a></h2>
<ul>
<li><strong>Q: Android Studio complains about Python not being found when building.</strong></li>
<li>A: Make sure that the <code>python</code> binary is on your <code>PATH</code>. On Windows, in addition to that,
it might be required to add its full path to the <code>rust.pythonCommand</code> entry in  <code>$project_root/local.properties</code>.</li>
</ul>
<h1><a class="header" href="#rust-component" id="rust-component">Rust component</a></h1>
<p>The majority of the Glean SDK is implemented as a Rust component, to be usable across all platforms.</p>
<p>This includes:</p>
<ul>
<li>Implementations of all metric types</li>
<li>A storage layer</li>
<li>A ping serializer</li>
</ul>
<h1><a class="header" href="#dependency-management-guidelines" id="dependency-management-guidelines">Dependency Management Guidelines</a></h1>
<hr />
<p>This is currently copied from <a href="https://github.com/mozilla/application-services/blob/4347ea9c590d2319db1c994680832cc20bc3758d/docs/dependency-management.md">application-services documentation</a>.</p>
<hr />
<p>This repo uses third-party code from a variety of sources, so we need to be mindful
of how these dependencies will affect our consumers.  Considerations include:</p>
<ul>
<li>General code quality.</li>
<li><a href="https://www.mozilla.org/en-US/MPL/license-policy/#Licenses_Compatible_with_the_MPL">Licensing compatibility</a>.</li>
<li>Handling of security vulnerabilities.</li>
<li>The potential for <a href="https://medium.com/intrinsic/compromised-npm-package-event-stream-d47d08605502">supply-chain compromise</a>.</li>
</ul>
<p>We're still evolving our policies in this area, but these are the
guidelines we've developed so far.</p>
<h2><a class="header" href="#rust-code" id="rust-code">Rust Code</a></h2>
<p>Unlike <a href="https://firefox-source-docs.mozilla.org/build/buildsystem/rust.html">Firefox</a>,
we do not vendor third-party source code directly into the repo.  Instead we rely on
<code>Cargo.lock</code> and its hash validation to ensure that each build uses an identical copy
of all third-party crates.  These are the measures we use for ongoing maintence of our
existing dependencies:</p>
<ul>
<li>Check <code>Cargo.lock</code> into the repository.</li>
<li>Generate built artifacts using the <code>--locked</code> flag to <code>cargo build</code>, as an additional
assurance that the existing <code>Cargo.lock</code> will be respected.
<ul>
<li>TODO: how to actually make this happen via rust-android-gradle plugin?</li>
</ul>
</li>
<li>Regularly run <a href="https://github.com/RustSec/cargo-audit">cargo-audit</a> in CI to alert us to
security problems in our dependencies.
<ul>
<li>It runs on every PR, and once per hour as a scheduled job with failures reported to slack.</li>
</ul>
</li>
<li>Use <a href="https://github.com/onur/cargo-license">cargo-license</a> for a basic licence-compatibility
check as part of CI, to guard against human error.</li>
</ul>
<p>Adding a new dependency, whether we like it or not, is a big deal - that dependency and everything
it brings with it will become part of Firefox-branded products that we ship to end users.
We try to balance this responsibility against the many benefits of using existing code, as follows:</p>
<ul>
<li>In general, be conservative in adding new third-party dependencies.
<ul>
<li>For trivial functionality, consider just writing it yourself.
Remember the cautionary tale of <a href="https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/">left-pad</a>.</li>
<li>Check if we already have a crate in our dependency tree that can provide the needed functionality.</li>
</ul>
</li>
<li>Prefer crates that have a a high level of due-dilligence already applied, such as:
<ul>
<li>Crates that are <a href="https://dxr.mozilla.org/mozilla-central/source/third_party/rust">already vendored into Firefox</a>.</li>
<li>Crates from <a href="https://github.com/rust-lang-nursery">rust-lang-nursery</a>.</li>
<li>Crates that appear to be widely used in the Rust community.</li>
</ul>
</li>
<li>Check that it is clearly licensed and is <a href="https://www.mozilla.org/en-US/MPL/license-policy/#Licenses_Compatible_with_the_MPL">MPL-2.0 compatible</a>.</li>
<li>Take the time to investigate the crate's source and ensure it is suitably high-quality.
<ul>
<li>Be especially wary of uses of <code>unsafe</code>, or of code that is unusually resource-intensive to build.</li>
<li>Dev dependencies do not require as much scrutiny as dependencies that will ship in consuming applications,
but should still be given some thought.
<ul>
<li>There is still the potential for supply-chain compromise with dev dependencies!</li>
</ul>
</li>
</ul>
</li>
<li>Explicitly describe your consideration of these points in the PR that introduces the new dependency.</li>
</ul>
<p>Updating to new versions of existing dependencies is a normal part of software development
and is not accompanied by any partiulcar ceremony.</p>
<h1><a class="header" href="#adding-a-new-metric-type" id="adding-a-new-metric-type">Adding a new metric type</a></h1>
<p>Data in the Glean SDK is stored in so-called metrics.
You can find the full list of implemented metric types <a href="dev/core/../../user/metrics/index.html">in the user overview</a>.</p>
<p>Adding a new metric type involves defining the metric type's API, its persisted and in-memory storage as well as its serialization into the ping payload.</p>
<h2><a class="header" href="#the-metric-types-api" id="the-metric-types-api">The metric type's API</a></h2>
<p>A metric type implementation is defined in its own file under <code>glean-core/src/metrics/</code>, e.g. <code>glean-core/src/metrics/counter.rs</code> for a <a href="dev/core/../../user/metrics/counter.html">Counter</a>.</p>
<p>Start by defining a structure to hold the metric's metadata:</p>
<pre><code class="language-rust noplaypen">#[derive(Clone, Debug)]
pub struct CounterMetric {
    meta: CommonMetricData
}
</code></pre>
<p>Implement the <code>MetricType</code> trait to create a metric from the meta data as well as expose the meta data.
This also gives you a <code>should_record</code> method on the metric type.</p>
<pre><code class="language-rust noplaypen">impl MetricType for CounterMetric {
    fn meta(&amp;self) -&gt; &amp;CommonMetricData {
        &amp;self.meta
    }

    fn meta_mut(&amp;mut self) -&gt; &amp;mut CommonMetricData {
        &amp;mut self.meta
    }
}
</code></pre>
<p>Its implementation should have a way to create a new metric from the common metric data. It should be the same for all metric types.</p>
<pre><code class="language-rust noplaypen">impl CounterMetric {
    pub fn new(meta: CommonMetricData) -&gt; Self {
        Self { meta }
    }
}
</code></pre>
<p>Implement each method for the type. The first argument to accept should always be <code>glean: &amp;Glean</code>, that is: a reference to the <code>Glean</code> object, used to access the storage:</p>
<pre><code class="language-rust noplaypen">impl CounterMetric { // same block as above
    pub fn add(&amp;self, glean: &amp;Glean, amount: i32) {
        // Always include this check!
        if !self.should_record() {
            return;
        }

        // Do error handling here

        glean
            .storage()
            .record_with(&amp;self.meta, |old_value| match old_value {
                Some(Metric::Counter(old_value)) =&gt; Metric::Counter(old_value + amount),
                _ =&gt; Metric::Counter(amount),
            })
    }
}
</code></pre>
<p>Use <code>glean.storage().record()</code> to record a fixed value or <code>glean.storage.record_with()</code> to construct a new value from the currently stored one.</p>
<p>The storage operation makes use of the metric's variant of the <code>Metric</code> enumeration.</p>
<h2><a class="header" href="#the-metric-enumeration" id="the-metric-enumeration">The <code>Metric</code> enumeration</a></h2>
<p>Persistence and in-memory serialization as well as ping payload serialization are handled through the <code>Metric</code> enumeration.
This is defined in <code>glean-core/src/metrics/mod.rs</code>.
Variants of this enumeration are used in the storage implementation of the metric type.</p>
<p>To add a new metric type, include the metric module and declare its use, then add a new variant to the <code>Metric</code> enum:</p>
<pre><code class="language-rust noplaypen">
mod counter;

// ...

pub use self::counter::CounterMetric;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum Metric {
    // ...
    Counter(i32),
}
</code></pre>
<p>Then modify the below implementation and define the right category name for the new type. This will be used in the ping payload:</p>
<pre><code class="language-rust noplaypen">impl Metric {
    pub fn category(&amp;self) -&gt; &amp;'static str {
        match self {
            // ...
            Metric::Counter(_) =&gt; &quot;counter&quot;,
        }
    }
}
</code></pre>
<p>Finally, define the ping payload serialization (as JSON).
In the simple cases where the in-memory representation maps to its JSON representation it is enough to call the <code>json!</code> macro.</p>
<pre><code class="language-rust noplaypen">impl Metric { // same block as above
    pub fn as_json(&amp;self) -&gt; JsonValue {
        match self {
            // ...
            Metric::Counter(c) =&gt; json!(c),
        }
    }
}
</code></pre>
<p>For more complex serialization consider implementing serialization logic as a function returning a <a href="https://docs.rs/serde_json/*/serde_json/enum.Value.html"><code>serde_json::Value</code></a>
or another object that can be serialized.</p>
<p>For example, the <code>DateTime</code> serializer has the following entry, where <code>get_iso_time_string</code> is a function to convert from the <code>DateTime</code> metric representation to a string:</p>
<pre><code class="language-rust noplaypen">Metric::Datetime(d, time_unit) =&gt; json!(get_iso_time_string(*d, *time_unit)),
</code></pre>
<h2><a class="header" href="#ffi-layer" id="ffi-layer">FFI layer</a></h2>
<p>In order to use a new metric type over the FFI layer, it needs implementations in the FFI component and the platform-part.</p>
<h3><a class="header" href="#ffi-component" id="ffi-component">FFI component</a></h3>
<p>The FFI component implementation can be found in <code>glean-core/ffi/src</code>.
Each metric type is implemented in its own module.</p>
<p>Add a new file named after your metric, e.g. <code>glean-core/ffi/src/counter.rs</code>, and declare it in <code>glean-core/ffi/src/lib.rs</code> with <code>mod counter;</code>.</p>
<p>In the metric type module add a global map for your metric type and define the destructor:</p>
<pre><code class="language-rust noplaypen">lazy_static! {
    static ref COUNTER_METRICS: ConcurrentHandleMap&lt;CounterMetric&gt; = ConcurrentHandleMap::new();
}
define_handle_map_deleter!(COUNTER_METRICS, glean_destroy_counter_metric);
</code></pre>
<p>Add a function to create new instances of this metric type:</p>
<pre><code class="language-rust noplaypen">#[no_mangle]
pub extern &quot;C&quot; fn glean_new_counter_metric(
    category: FfiStr,
    name: FfiStr,
    send_in_pings: RawStringArray,
    send_in_pings_len: i32,
    lifetime: i32,
    disabled: u8,
) -&gt; u64 {
    COUNTER_METRICS.insert_with_log(|| {
        let send_in_pings = unsafe { from_raw_string_array(send_in_pings, send_in_pings_len) };
        let lifetime = Lifetime::try_from(lifetime)?;

        Ok(CounterMetric::new(CommonMetricData {
            name: name.into_string(),
            category: category.into_string(),
            send_in_pings,
            lifetime,
            disabled: disabled != 0,
        }))
    })
}
</code></pre>
<p>On the Rust side add wrappers around the metric type's storage functions:</p>
<pre><code class="language-rust noplaypen">#[no_mangle]
pub extern &quot;C&quot; fn glean_counter_add(glean_handle: u64, metric_id: u64, amount: i32) {
    GLEAN.call_infallible(glean_handle, |glean| {
        COUNTER_METRICS.call_infallible(metric_id, |metric| {
            metric.add(glean, amount);
        })
    })
}
</code></pre>
<p>Additionally, expose the <code>should_record</code> function:</p>
<pre><code class="language-rust noplaypen">#[no_mangle]
pub extern &quot;C&quot; fn glean_counter_should_record(glean_handle: u64, metric_id: u64) -&gt; u8 {
    GLEAN.call_infallible(glean_handle, |glean| {
        COUNTER_METRICS.call_infallible(metric_id, |metric| metric.should_record(&amp;glean))
    })
}
</code></pre>
<h3><a class="header" href="#platform-part-kotlin" id="platform-part-kotlin">Platform-part (Kotlin)</a></h3>
<p>The platform-specific FFI wrapper needs the definitions of these new functions.
For Kotlin this is in <code>glean-core/android/src/main/java/mozilla/telemetry/glean/rust/LibGleanFFI.kt</code>:</p>
<pre><code class="language-kotlin">fun glean_new_counter_metric(category: String, name: String, send_in_pings: StringArray, send_in_pings_len: Int, lifetime: Int, disabled: Byte): Long
fun glean_destroy_counter_metric(handle: Long, error: RustError.ByReference)
fun glean_counter_add(glean_handle: Long, metric_id: Long, amount: Int)
fun glean_counter_should_record(glean_handle: Long, metric_id: Long): Byte
</code></pre>
<p>Finally, create a platform-specific metric type wrapper.
For Kotlin this would be <code>glean-core/android/src/main/java/mozilla/telemetry/glean/private/CounterMetricType.kt</code>:</p>
<pre><code class="language-kotlin">class CounterMetricType(
    disabled: Boolean,
    category: String,
    lifetime: Lifetime,
    name: String,
    val sendInPings: List&lt;String&gt;
) {
    private var handle: Long

    init {
        println(&quot;New Counter: $category.$name&quot;)

        val ffiPingsList = StringArray(sendInPings.toTypedArray(), &quot;utf-8&quot;)
        this.handle = LibGleanFFI.INSTANCE.glean_new_counter_metric(
                category = category,
                name = name,
                send_in_pings = ffiPingsList,
                send_in_pings_len = sendInPings.size,
                lifetime = lifetime.ordinal,
                disabled = disabled.toByte())
    }

    protected fun finalize() {
        if (this.handle != 0L) {
            val error = RustError.ByReference()
            LibGleanFFI.INSTANCE.glean_destroy_counter_metric(this.handle, error)
        }
    }

    fun shouldRecord(): Boolean {
        // Don't record metrics if we aren't initialized
        if (!Glean.isInitialized()) {
            return false
        }

        return LibGleanFFI.INSTANCE.glean_counter_should_record(Glean.handle, this.handle).toBoolean()
    }

    fun add(amount: Int = 1) {
        if (!shouldRecord()) {
            return
        }

        @Suppress(&quot;EXPERIMENTAL_API_USAGE&quot;)
        Dispatchers.API.launch {
            LibGleanFFI.INSTANCE.glean_counter_add(
                Glean.handle,
                this@CounterMetricType.handle,
                amount)
        }
    }
}
</code></pre>
<h1><a class="header" href="#internal-design-details" id="internal-design-details">Internal design details</a></h1>
<h2><a class="header" href="#clearing-metrics-when-disablingenabling-glean" id="clearing-metrics-when-disablingenabling-glean">Clearing metrics when disabling/enabling Glean</a></h2>
<p>When disabling upload (<code>Glean.setUploadEnabled(false)</code>), metrics are also cleared to prevent their storage on the local device, and lessen the likelihood
of accidentally sending them.
There are a couple of exceptions to this:</p>
<ul>
<li>
<p><code>first_run_date</code> is retained so it isn't reset if metrics are later re-enabled.</p>
</li>
<li>
<p><code>client_id</code> is set to the special value <code>&quot;c0ffeec0-ffee-c0ff-eec0-ffeec0ffeec0&quot;</code>. This should make it possible to detect the error case when metrics are sent from a client that has been disabled.</p>
</li>
</ul>
<p>When re-enabling metrics:</p>
<ul>
<li>
<p><code>first_run_date</code> is left as-is. (It should remain a correct date of first run of the application, unaffected by disabling/enabling the Glean SDK).</p>
</li>
<li>
<p>The <code>client_id</code> is set to a newly-generated random UUID. It has no connection to the <code>client_id</code> used prior to disabling the Glean SDK.</p>
</li>
<li>
<p>Application lifetime metrics owned by Glean are regenerated from scratch so that they will appear in subsequent pings. This is the same process that happens during every startup of the application when the Glean SDK is enabled. The application is also responsible for setting any application lifetime metrics that it manages at this time.</p>
</li>
<li>
<p>Ping lifetime metrics do not need special handling.  They will begin recording again after metric uploading is re-enabled.</p>
</li>
</ul>
<h2><a class="header" href="#reservered-ping-names" id="reservered-ping-names">Reservered ping names</a></h2>
<p>The Glean SDK reserves all ping names starting with <code>glean_</code>.</p>
<p>This currently includes, but is not limited to:</p>
<ul>
<li><code>glean_client_info</code></li>
<li><code>glean_internal_info</code></li>
</ul>
<h1><a class="header" href="#ffi-layer-1" id="ffi-layer-1">FFI layer</a></h1>
<p>The core part of the Glean SDK cross-platform implementation provides an FFI layer for its API.
This FFI layer can be consumed by platform-specific bindings, such as the <a href="dev/ffi/../android/index.html">Kotlin bindings for Android</a>.</p>
<h1><a class="header" href="#when-to-use-what-method-of-passing-data-between-rust-and-javaswift" id="when-to-use-what-method-of-passing-data-between-rust-and-javaswift">When to use what method of passing data between Rust and Java/Swift</a></h1>
<hr />
<p>This is currently copied from <a href="https://github.com/mozilla/application-services/blob/4347ea9c590d2319db1c994680832cc20bc3758d/docs/howtos/when-to-use-what-in-the-ffi.md">application-services documentation</a>.</p>
<hr />
<p>There are a bunch of options here. For the purposes of our discussion,
there are two kinds of values you may want to pass over the FFI.</p>
<ol>
<li>Types with identity (includes stateful types, resource types, or anything that
isn't really serializable).</li>
<li>Plain ol' data.</li>
</ol>
<h2><a class="header" href="#types-with-identity" id="types-with-identity">Types with identity</a></h2>
<p>Examples of this are things like database connections, the FirefoxAccounts
struct, etc. These types are complex, implemented in rust, and it's not
unreasonable for them to come to Java/Kotlin as a type representing a
resource (e.g. implementing <code>Closable</code>/<code>AutoClosable</code>).</p>
<p>You have two choices here:</p>
<ol>
<li>
<p>Use a <code>ConcurrentHandleMap</code> to store all instances of your object, and
pass the handle back and forth as a u64 from Rust / Long from Kotlin.</p>
<p>This is recommended for most cases, as it's the hardest to mess up.
Additionally, for types T such that <code>&amp;T: Sync + Send</code>, or that you
need to call <code>&amp;mut self</code> method, this is the safest choice.</p>
<p>Additionally, this will ensure panic-safety, as you'll poison your Mutex.</p>
<p>The <a href="https://docs.rs/ffi-support/*/ffi_support/handle_map/index.html"><code>ffi_support::handle_map</code> docs</a>
are good, and under <code>ConcurrentHandleMap</code> include an example of how to set
this up. You can also look at most of the FFI crates, as they do this (with
the exception of <code>rc_log</code>, which has unique requirements).</p>
</li>
<li>
<p>Using an opaque pointer. This is generally only recommended for rare cases
like the <code>PlacesInterruptHandle</code> (or the <code>LogAdapterState</code> from <code>rc_log</code>,
although it will probably eventually use a handle).</p>
<p>It's good if your synchronization or threading requirements are somewhat
complex and handled separately, such that the additional overhead of
the <code>ConcurrentHandleMap</code> is undesirable. You should probably talk to us
before adding another type that works this way, to make sure it's sound.</p>
<p>The <a href="https://docs.rs/ffi-support/*/ffi_support/macro.implement_into_ffi_by_pointer.html"><code>ffi_support</code> docs</a>
discuss how to do this, or take a look at how it's done for
<code>PlacesInterruptHandle</code>).</p>
</li>
</ol>
<h2><a class="header" href="#plain-old-data" id="plain-old-data">Plain Old Data</a></h2>
<p>This includes both primitive values, strings, arrays, or arbitrarially nested
structures containing them.</p>
<h3><a class="header" href="#primitives" id="primitives">Primitives</a></h3>
<p>Specifically numeric primitives. These we'll tackle first since they're the
easiest.</p>
<p>In general, you can just pass them as you wish. There are a couple of
exceptions/caveats. All of them are caused by JNA/Android issues (Swift has very
good support for calling over the FFI), but it's our lowest common denominator.</p>
<ol>
<li>
<p><code>bool</code>: Don't use it. JNA doesn't handle it well. Instead, use a numeric type
(like <code>u8</code>) and represent 0 for false and 1 for true for interchange over the
FFI, converting back to a Kotlin <code>Boolean</code> or swift <code>Bool</code> after (as to
not expose this somewhat annoying limitation in our public API).</p>
</li>
<li>
<p><code>usize</code>/<code>isize</code>: These cause the structure size to be different based on the
platform. JNA does handle this if you use <code>NativeSize</code>, but it's awkward,
incompatible with it's Direct Mapping optimization (which we don't use but
want to in the future), and has more overhead than just using <code>i64</code>/<code>i32</code> for
<code>Long</code>/<code>Int</code>. (You can also use <code>u64</code>/<code>u32</code> for <code>Long</code>/<code>Int</code>, if you're certain the
value is not negative)</p>
</li>
<li>
<p><code>char</code>: I really don't see a reason you need to pass a single codepoint over the
FFI, but if someone needs to do this, they instead should just pass it as a <code>u32</code>.</p>
<p>If you do this, you should probably be aware of the fact that Java chars are 16
bit, and Swift <code>Character</code>s are actually strings (they represent Extended
Grapheme Clusters, not codepoints).</p>
</li>
</ol>
<h3><a class="header" href="#strings-1" id="strings-1">Strings</a></h3>
<p>These we pass as nul-terminated UTF-8 C-strings.</p>
<p>For return values, used <code>*mut c_char</code>, and for input, use
<a href="https://docs.rs/ffi-support/*/ffi_support/struct.FfiStr.html"><code>ffi_support::FfiStr</code></a></p>
<ol>
<li>
<p>If the string is returned from Rust to Kotlin/Swift, you need to expose a
string destructor from your ffi crate. See
<a href="https://docs.rs/ffi-support/*/ffi_support/macro.define_string_destructor.html"><code>ffi_support::define_string_destructor!</code></a>).</p>
<p>For converting to a <code>*mut c_char</code>, use either
<a href="https://docs.rs/ffi-support/*/ffi_support/fn.rust_string_to_c.html"><code>rust_string_to_c</code></a>
if you have a <code>String</code>, or
<a href="https://docs.rs/ffi-support/*/ffi_support/fn.opt_rust_string_to_c.html"><code>opt_rust_string_to_c</code></a>
for <code>Option&lt;String&gt;</code> (None becomes <code>std::ptr::null_mut()</code>).</p>
<p><strong>Important</strong>: In Kotlin, the type returned by a function that produces this
must be <code>Pointer</code>, and not <code>String</code>, and the parameter that the destructor takes
as input must also be <code>Pointer</code>.</p>
<p>Using <code>String</code> will <em>almost</em> work. JNA will convert the return value to
<code>String</code> automatically, leaking the value rust provides. Then, when passing
to the destructor, it will allocate a temporary buffer, pass it to Rust, which
we'll free, corrupting both heaps 💥. Oops!</p>
</li>
<li>
<p>If the string is passed into Rust from Kotlin/Swift, the rust code should
declare the parameter as a <a href="https://docs.rs/ffi-support/*/ffi_support/struct.FfiStr.html"><code>FfiStr&lt;'_&gt;</code></a>.
and things should then work more or less automatically. The <code>FfiStr</code> has methods
for extracting it's data as <code>&amp;str</code>, <code>Option&lt;&amp;str&gt;</code>, <code>String</code>, and <code>Option&lt;String&gt;</code>.</p>
</li>
</ol>
<p>It's also completely fine to use Protobufs or JSON for this case!</p>
<h3><a class="header" href="#aggregates" id="aggregates">Aggregates</a></h3>
<p>This is any type that's more complex than a primitive or a string (arrays,
structures, and combinations there-in). There are two options we recommend for
these cases:</p>
<ol>
<li>
<p>Passing data using protobufs. See the
&quot;<a href="https://github.com/mozilla/application-services/blob/master/docs/howtos/passing-protobuf-data-over-ffi.md">Using protobuf-encoded data over Rust FFI</a>&quot;
document for details on how to do this. We recommend this for all new use cases, unless
you have a specific reason that JSON is better (e.g. semi-opaque JSON encoded data is
desired on the other side).</p>
</li>
<li>
<p>Passing data as JSON. This is very easy, and useful for prototyping, however
much slower, requires a great deal of copying and redundant encode/decode
steps (in general, the data will be copied at least 4 times to make this
work, and almost certainly more in practice), and can be done relatively
easily by <code>derive(Serialize, Deserialize)</code>, and adding
<a href="https://docs.rs/ffi-support/*/ffi_support/macro.implement_into_ffi_by_json.html"><code>ffi_support::implement_into_ffi_by_json</code></a>
into the crate that defines the type.</p>
<p>For new non-test code this is not a recommended approach.
For test code, this can be a useful performance/simplicity tradeoff to make.</p>
</li>
</ol>
<h1><a class="header" href="#contributing-to-the-glean-sdk" id="contributing-to-the-glean-sdk">Contributing to the Glean SDK</a></h1>
<blockquote>
<p><strong>Note:</strong> This document describes contributing to the cross-platform implementation of the Glean SDK. To contribute to the Android-specific implementation, see <a href="https://github.com/mozilla-mobile/android-components">android-components</a>.</p>
</blockquote>
<p>Anyone is welcome to help with the Glean SDK project. Feel free to get in touch with other community members on IRC
or through issues here on GitHub.</p>
<ul>
<li>IRC: <code>#telemetry</code> on <code>irc.mozilla.org</code></li>
<li>and of course, <a href="https://github.com/mozilla/glean/issues">the issues list</a></li>
</ul>
<p>Participation in this project is governed by the
<a href="https://www.mozilla.org/en-US/about/governance/policies/participation/">Mozilla Community Participation Guidelines</a>.</p>
<h2><a class="header" href="#bug-reports" id="bug-reports">Bug Reports</a></h2>
<p>You can file issues here on GitHub. Please try to include as much information as you can and under what conditions
you saw the issue.</p>
<h2><a class="header" href="#making-code-changes" id="making-code-changes">Making Code Changes</a></h2>
<p>To work on the code in this repo you will need to be familiar with
the <a href="https://www.rust-lang.org/">Rust</a> programming language.
You can get a working rust compiler and toolchain via <a href="https://rustup.rs/">rustup</a>.</p>
<p>You can check that everything compiles by running the following from the
root of your checkout:</p>
<pre><code>cargo test --all
</code></pre>
<p>If you plan to work on the Android component bindings, you should also review
the instructions for <a href="https://github.com/mozilla/glean/blob/master/docs/dev/setup-android-build-environment.md">setting up an Android build environment</a></p>
<h2><a class="header" href="#sending-pull-requests" id="sending-pull-requests">Sending Pull Requests</a></h2>
<p>Patches should be submitted as <a href="https://help.github.com/articles/about-pull-requests/">pull requests</a> (PRs).</p>
<p>Before submitting a PR:</p>
<ul>
<li>Your code must run and pass all the automated tests before you submit your PR for review. &quot;Work in progress&quot; pull requests are allowed to be submitted, but should be clearly labeled as such and should not be merged until all tests pass and the code has been reviewed.
<ul>
<li>Run <code>cargo test --all</code> to make sure all tests still pass and no warnings are emitted.</li>
<li>Run <code>cargo fmt</code> to ensure the code is formatted correctly.</li>
</ul>
</li>
<li>Your patch should include new tests that cover your changes. It is your and your reviewer's responsibility to ensure your patch includes adequate tests.</li>
</ul>
<p>When submitting a PR:</p>
<ul>
<li>You agree to license your code under the project's open source license (<a href="/LICENSE">MPL 2.0</a>).</li>
<li>Base your branch off the current <code>master</code> (see below for an example workflow).</li>
<li>Add both your code and new tests if relevant.</li>
<li>Run <code>cargo test</code> to make sure your code passes linting and tests.</li>
<li>Please do not include merge commits in pull requests; include only commits with the new relevant code.</li>
</ul>
<h2><a class="header" href="#code-review" id="code-review">Code Review</a></h2>
<p>This project is production Mozilla code and subject to our <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Committing_Rules_and_Responsibilities">engineering practices and quality standards</a>. Every patch must be peer reviewed by a member of the Application Services team.</p>
<p>The following language-specific API docs are available:</p>
<ul>
<li><a href="api/../../javadoc/glean/index.html">Kotlin API docs</a></li>
<li><a href="api/../../docs/index.html">Rust core (internal) API docs</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
